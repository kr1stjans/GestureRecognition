# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""XMM - Probabilistic Models for Motion Recognition and Mapping"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_xmm', [dirname(__file__)])
        except ImportError:
            import _xmm
            return _xmm
        if fp is not None:
            try:
                _mod = imp.load_module('_xmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _xmm = swig_import_helper()
    del swig_import_helper
else:
    import _xmm
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _xmm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _xmm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _xmm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _xmm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _xmm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _xmm.SwigPyIterator_copy(self)

    def next(self):
        return _xmm.SwigPyIterator_next(self)

    def __next__(self):
        return _xmm.SwigPyIterator___next__(self)

    def previous(self):
        return _xmm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _xmm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _xmm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _xmm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _xmm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _xmm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _xmm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _xmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _xmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectord___nonzero__(self)

    def __bool__(self):
        return _xmm.vectord___bool__(self)

    def __len__(self):
        return _xmm.vectord___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectord___setitem__(self, *args)

    def pop(self):
        return _xmm.vectord_pop(self)

    def append(self, x):
        return _xmm.vectord_append(self, x)

    def empty(self):
        return _xmm.vectord_empty(self)

    def size(self):
        return _xmm.vectord_size(self)

    def swap(self, v):
        return _xmm.vectord_swap(self, v)

    def begin(self):
        return _xmm.vectord_begin(self)

    def end(self):
        return _xmm.vectord_end(self)

    def rbegin(self):
        return _xmm.vectord_rbegin(self)

    def rend(self):
        return _xmm.vectord_rend(self)

    def clear(self):
        return _xmm.vectord_clear(self)

    def get_allocator(self):
        return _xmm.vectord_get_allocator(self)

    def pop_back(self):
        return _xmm.vectord_pop_back(self)

    def erase(self, *args):
        return _xmm.vectord_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectord(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectord_push_back(self, x)

    def front(self):
        return _xmm.vectord_front(self)

    def back(self):
        return _xmm.vectord_back(self)

    def assign(self, n, x):
        return _xmm.vectord_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectord_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectord_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectord_reserve(self, n)

    def capacity(self):
        return _xmm.vectord_capacity(self)
    __swig_destroy__ = _xmm.delete_vectord
    __del__ = lambda self: None
vectord_swigregister = _xmm.vectord_swigregister
vectord_swigregister(vectord)

class vectorf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorf___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorf___bool__(self)

    def __len__(self):
        return _xmm.vectorf___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorf___setitem__(self, *args)

    def pop(self):
        return _xmm.vectorf_pop(self)

    def append(self, x):
        return _xmm.vectorf_append(self, x)

    def empty(self):
        return _xmm.vectorf_empty(self)

    def size(self):
        return _xmm.vectorf_size(self)

    def swap(self, v):
        return _xmm.vectorf_swap(self, v)

    def begin(self):
        return _xmm.vectorf_begin(self)

    def end(self):
        return _xmm.vectorf_end(self)

    def rbegin(self):
        return _xmm.vectorf_rbegin(self)

    def rend(self):
        return _xmm.vectorf_rend(self)

    def clear(self):
        return _xmm.vectorf_clear(self)

    def get_allocator(self):
        return _xmm.vectorf_get_allocator(self)

    def pop_back(self):
        return _xmm.vectorf_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorf_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorf(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorf_push_back(self, x)

    def front(self):
        return _xmm.vectorf_front(self)

    def back(self):
        return _xmm.vectorf_back(self)

    def assign(self, n, x):
        return _xmm.vectorf_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorf_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorf_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorf_reserve(self, n)

    def capacity(self):
        return _xmm.vectorf_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorf
    __del__ = lambda self: None
vectorf_swigregister = _xmm.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectors, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectors___nonzero__(self)

    def __bool__(self):
        return _xmm.vectors___bool__(self)

    def __len__(self):
        return _xmm.vectors___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectors___setitem__(self, *args)

    def pop(self):
        return _xmm.vectors_pop(self)

    def append(self, x):
        return _xmm.vectors_append(self, x)

    def empty(self):
        return _xmm.vectors_empty(self)

    def size(self):
        return _xmm.vectors_size(self)

    def swap(self, v):
        return _xmm.vectors_swap(self, v)

    def begin(self):
        return _xmm.vectors_begin(self)

    def end(self):
        return _xmm.vectors_end(self)

    def rbegin(self):
        return _xmm.vectors_rbegin(self)

    def rend(self):
        return _xmm.vectors_rend(self)

    def clear(self):
        return _xmm.vectors_clear(self)

    def get_allocator(self):
        return _xmm.vectors_get_allocator(self)

    def pop_back(self):
        return _xmm.vectors_pop_back(self)

    def erase(self, *args):
        return _xmm.vectors_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectors(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectors_push_back(self, x)

    def front(self):
        return _xmm.vectors_front(self)

    def back(self):
        return _xmm.vectors_back(self)

    def assign(self, n, x):
        return _xmm.vectors_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectors_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectors_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectors_reserve(self, n)

    def capacity(self):
        return _xmm.vectors_capacity(self)
    __swig_destroy__ = _xmm.delete_vectors
    __del__ = lambda self: None
vectors_swigregister = _xmm.vectors_swigregister
vectors_swigregister(vectors)

class vectorl(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorl, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorl_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorl___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorl___bool__(self)

    def __len__(self):
        return _xmm.vectorl___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectorl___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorl___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorl___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorl___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorl___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorl___setitem__(self, *args)

    def pop(self):
        return _xmm.vectorl_pop(self)

    def append(self, x):
        return _xmm.vectorl_append(self, x)

    def empty(self):
        return _xmm.vectorl_empty(self)

    def size(self):
        return _xmm.vectorl_size(self)

    def swap(self, v):
        return _xmm.vectorl_swap(self, v)

    def begin(self):
        return _xmm.vectorl_begin(self)

    def end(self):
        return _xmm.vectorl_end(self)

    def rbegin(self):
        return _xmm.vectorl_rbegin(self)

    def rend(self):
        return _xmm.vectorl_rend(self)

    def clear(self):
        return _xmm.vectorl_clear(self)

    def get_allocator(self):
        return _xmm.vectorl_get_allocator(self)

    def pop_back(self):
        return _xmm.vectorl_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorl_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorl(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorl_push_back(self, x)

    def front(self):
        return _xmm.vectorl_front(self)

    def back(self):
        return _xmm.vectorl_back(self)

    def assign(self, n, x):
        return _xmm.vectorl_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorl_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorl_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorl_reserve(self, n)

    def capacity(self):
        return _xmm.vectorl_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorl
    __del__ = lambda self: None
vectorl_swigregister = _xmm.vectorl_swigregister
vectorl_swigregister(vectorl)

class setl(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, setl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, setl, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.setl_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.setl___nonzero__(self)

    def __bool__(self):
        return _xmm.setl___bool__(self)

    def __len__(self):
        return _xmm.setl___len__(self)

    def append(self, x):
        return _xmm.setl_append(self, x)

    def __contains__(self, x):
        return _xmm.setl___contains__(self, x)

    def __getitem__(self, i):
        return _xmm.setl___getitem__(self, i)

    def add(self, x):
        return _xmm.setl_add(self, x)

    def discard(self, x):
        return _xmm.setl_discard(self, x)

    def __init__(self, *args):
        this = _xmm.new_setl(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _xmm.setl_empty(self)

    def size(self):
        return _xmm.setl_size(self)

    def clear(self):
        return _xmm.setl_clear(self)

    def swap(self, v):
        return _xmm.setl_swap(self, v)

    def count(self, x):
        return _xmm.setl_count(self, x)

    def begin(self):
        return _xmm.setl_begin(self)

    def end(self):
        return _xmm.setl_end(self)

    def rbegin(self):
        return _xmm.setl_rbegin(self)

    def rend(self):
        return _xmm.setl_rend(self)

    def erase(self, *args):
        return _xmm.setl_erase(self, *args)

    def find(self, x):
        return _xmm.setl_find(self, x)

    def lower_bound(self, x):
        return _xmm.setl_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.setl_upper_bound(self, x)

    def equal_range(self, x):
        return _xmm.setl_equal_range(self, x)

    def insert(self, __x):
        return _xmm.setl_insert(self, __x)
    __swig_destroy__ = _xmm.delete_setl
    __del__ = lambda self: None
setl_swigregister = _xmm.setl_swigregister
setl_swigregister(setl)

class vectorgauss(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgauss, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgauss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgauss___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgauss___bool__(self)

    def __len__(self):
        return _xmm.vectorgauss___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgauss___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgauss___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgauss___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgauss___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgauss___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgauss___setitem__(self, *args)

    def pop(self):
        return _xmm.vectorgauss_pop(self)

    def append(self, x):
        return _xmm.vectorgauss_append(self, x)

    def empty(self):
        return _xmm.vectorgauss_empty(self)

    def size(self):
        return _xmm.vectorgauss_size(self)

    def swap(self, v):
        return _xmm.vectorgauss_swap(self, v)

    def begin(self):
        return _xmm.vectorgauss_begin(self)

    def end(self):
        return _xmm.vectorgauss_end(self)

    def rbegin(self):
        return _xmm.vectorgauss_rbegin(self)

    def rend(self):
        return _xmm.vectorgauss_rend(self)

    def clear(self):
        return _xmm.vectorgauss_clear(self)

    def get_allocator(self):
        return _xmm.vectorgauss_get_allocator(self)

    def pop_back(self):
        return _xmm.vectorgauss_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgauss_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgauss(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgauss_push_back(self, x)

    def front(self):
        return _xmm.vectorgauss_front(self)

    def back(self):
        return _xmm.vectorgauss_back(self)

    def assign(self, n, x):
        return _xmm.vectorgauss_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgauss_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgauss_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgauss_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgauss_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgauss
    __del__ = lambda self: None
vectorgauss_swigregister = _xmm.vectorgauss_swigregister
vectorgauss_swigregister(vectorgauss)

class vectorgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgmm___bool__(self)

    def __len__(self):
        return _xmm.vectorgmm___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgmm___setitem__(self, *args)

    def pop(self):
        return _xmm.vectorgmm_pop(self)

    def append(self, x):
        return _xmm.vectorgmm_append(self, x)

    def empty(self):
        return _xmm.vectorgmm_empty(self)

    def size(self):
        return _xmm.vectorgmm_size(self)

    def swap(self, v):
        return _xmm.vectorgmm_swap(self, v)

    def begin(self):
        return _xmm.vectorgmm_begin(self)

    def end(self):
        return _xmm.vectorgmm_end(self)

    def rbegin(self):
        return _xmm.vectorgmm_rbegin(self)

    def rend(self):
        return _xmm.vectorgmm_rend(self)

    def clear(self):
        return _xmm.vectorgmm_clear(self)

    def get_allocator(self):
        return _xmm.vectorgmm_get_allocator(self)

    def pop_back(self):
        return _xmm.vectorgmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgmm(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgmm_push_back(self, x)

    def front(self):
        return _xmm.vectorgmm_front(self)

    def back(self):
        return _xmm.vectorgmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorgmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgmm
    __del__ = lambda self: None
vectorgmm_swigregister = _xmm.vectorgmm_swigregister
vectorgmm_swigregister(vectorgmm)

class vectorhmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorhmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorhmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorhmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorhmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorhmm___bool__(self)

    def __len__(self):
        return _xmm.vectorhmm___len__(self)

    def __getslice__(self, i, j):
        return _xmm.vectorhmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorhmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorhmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorhmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorhmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorhmm___setitem__(self, *args)

    def pop(self):
        return _xmm.vectorhmm_pop(self)

    def append(self, x):
        return _xmm.vectorhmm_append(self, x)

    def empty(self):
        return _xmm.vectorhmm_empty(self)

    def size(self):
        return _xmm.vectorhmm_size(self)

    def swap(self, v):
        return _xmm.vectorhmm_swap(self, v)

    def begin(self):
        return _xmm.vectorhmm_begin(self)

    def end(self):
        return _xmm.vectorhmm_end(self)

    def rbegin(self):
        return _xmm.vectorhmm_rbegin(self)

    def rend(self):
        return _xmm.vectorhmm_rend(self)

    def clear(self):
        return _xmm.vectorhmm_clear(self)

    def get_allocator(self):
        return _xmm.vectorhmm_get_allocator(self)

    def pop_back(self):
        return _xmm.vectorhmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorhmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorhmm(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorhmm_push_back(self, x)

    def front(self):
        return _xmm.vectorhmm_front(self)

    def back(self):
        return _xmm.vectorhmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorhmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorhmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorhmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorhmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorhmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorhmm
    __del__ = lambda self: None
vectorhmm_swigregister = _xmm.vectorhmm_swigregister
vectorhmm_swigregister(vectorhmm)

class mapgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.mapgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.mapgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.mapgmm___bool__(self)

    def __len__(self):
        return _xmm.mapgmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.mapgmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.mapgmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.mapgmm_has_key(self, key)

    def keys(self):
        return _xmm.mapgmm_keys(self)

    def values(self):
        return _xmm.mapgmm_values(self)

    def items(self):
        return _xmm.mapgmm_items(self)

    def __contains__(self, key):
        return _xmm.mapgmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.mapgmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.mapgmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.mapgmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.mapgmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_mapgmm(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _xmm.mapgmm_empty(self)

    def size(self):
        return _xmm.mapgmm_size(self)

    def swap(self, v):
        return _xmm.mapgmm_swap(self, v)

    def begin(self):
        return _xmm.mapgmm_begin(self)

    def end(self):
        return _xmm.mapgmm_end(self)

    def rbegin(self):
        return _xmm.mapgmm_rbegin(self)

    def rend(self):
        return _xmm.mapgmm_rend(self)

    def clear(self):
        return _xmm.mapgmm_clear(self)

    def get_allocator(self):
        return _xmm.mapgmm_get_allocator(self)

    def count(self, x):
        return _xmm.mapgmm_count(self, x)

    def erase(self, *args):
        return _xmm.mapgmm_erase(self, *args)

    def find(self, x):
        return _xmm.mapgmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.mapgmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.mapgmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_mapgmm
    __del__ = lambda self: None
mapgmm_swigregister = _xmm.mapgmm_swigregister
mapgmm_swigregister(mapgmm)

class maphmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maphmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maphmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.maphmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.maphmm___nonzero__(self)

    def __bool__(self):
        return _xmm.maphmm___bool__(self)

    def __len__(self):
        return _xmm.maphmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.maphmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.maphmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.maphmm_has_key(self, key)

    def keys(self):
        return _xmm.maphmm_keys(self)

    def values(self):
        return _xmm.maphmm_values(self)

    def items(self):
        return _xmm.maphmm_items(self)

    def __contains__(self, key):
        return _xmm.maphmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.maphmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.maphmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.maphmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.maphmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_maphmm(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _xmm.maphmm_empty(self)

    def size(self):
        return _xmm.maphmm_size(self)

    def swap(self, v):
        return _xmm.maphmm_swap(self, v)

    def begin(self):
        return _xmm.maphmm_begin(self)

    def end(self):
        return _xmm.maphmm_end(self)

    def rbegin(self):
        return _xmm.maphmm_rbegin(self)

    def rend(self):
        return _xmm.maphmm_rend(self)

    def clear(self):
        return _xmm.maphmm_clear(self)

    def get_allocator(self):
        return _xmm.maphmm_get_allocator(self)

    def count(self, x):
        return _xmm.maphmm_count(self, x)

    def erase(self, *args):
        return _xmm.maphmm_erase(self, *args)

    def find(self, x):
        return _xmm.maphmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.maphmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.maphmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_maphmm
    __del__ = lambda self: None
maphmm_swigregister = _xmm.maphmm_swigregister
maphmm_swigregister(maphmm)


_xmm.XMM_VERSION_MAJOR_swigconstant(_xmm)
XMM_VERSION_MAJOR = _xmm.XMM_VERSION_MAJOR

_xmm.XMM_VERSION_MINOR_swigconstant(_xmm)
XMM_VERSION_MINOR = _xmm.XMM_VERSION_MINOR

_xmm.NONE_swigconstant(_xmm)
NONE = _xmm.NONE

_xmm.SHARED_MEMORY_swigconstant(_xmm)
SHARED_MEMORY = _xmm.SHARED_MEMORY

_xmm.BIMODAL_swigconstant(_xmm)
BIMODAL = _xmm.BIMODAL

_xmm.HIERARCHICAL_swigconstant(_xmm)
HIERARCHICAL = _xmm.HIERARCHICAL
class Listener(_object):
    """


    Abstract class for handling training set notifications.

    It is an abstract class that contains a pure virtual method "notify"
    called by a training set to notify changes of the training data

    C++ includes: xmm_common.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Listener
    __del__ = lambda self: None

    def notify(self, attribute):
        """
        virtual void
        xmm::Listener::notify(std::string attribute)=0

        pure virtual method for handling training set notifications.

        Parameters:
        -----------

        attribute:  name of the modified attribute of the training set 
        """
        return _xmm.Listener_notify(self, attribute)

Listener_swigregister = _xmm.Listener_swigregister
Listener_swigregister(Listener)
cvar = _xmm.cvar
null_vector_float = cvar.null_vector_float
null_vector_double = cvar.null_vector_double

class Writable(_object):
    """


    Abstract class for handling JSON + File I/O.

    the JSON I/O methods need to be implemented. writeFile and readFile
    methods can be used in Python for file I/O. The str() Python method is
    implemented to use with "print" in Python. It return the pretty-
    printed JSON String.

    C++ includes: xmm_common.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Writable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Writable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Writable
    __del__ = lambda self: None

    def to_json(self):
        """
        virtual JSONNode
        xmm::Writable::to_json() const  =0

        Write to JSON Node.

        JSON Node containing phrase information Todo include type attribute in
        each to_json function 
        """
        return _xmm.Writable_to_json(self)


    def from_json(self, root):
        """
        virtual void
        xmm::Writable::from_json(JSONNode root)=0

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format

        Todo add force_conversion optional argument? 
        """
        return _xmm.Writable_from_json(self, root)


    def writeFile(self, fileName):
        """
        void
        xmm::Writable::writeFile(char *fileName)

        write method for python wrapping ('write' keyword forbidden, name has
        to be different)

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable_writeFile(self, fileName)


    def readFile(self, fileName):
        """
        void
        xmm::Writable::readFile(char *fileName)

        read method for python wrapping ('read' keyword forbidden, name has to
        be different)

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable_readFile(self, fileName)


    def __str__(self):
        """
        std::string
        xmm::Writable::__str__()

        "print" method for python => returns the results of write method

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable___str__(self)

Writable_swigregister = _xmm.Writable_swigregister
Writable_swigregister(Writable)

class Phrase(Writable):
    """


    Data phrase.

    The Phrase class can be used to store unimodal and Bimodal data
    phrases. It can have an autonomous memory, or this memory can be
    shared with another data container. This can be specified by using the
    'SHARED_MEMORY' flag in the constructor. The phrase can be either
    unimodal - i.e. it contains a single 2D array to store the data, - or
    bimodal - i.e. it contains 2 arrays to store the input and output
    modalities. The latter case can be specified by using the 'BIMODAL'
    flag in the constructor.

    C++ includes: phrase.h 
    """

    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Phrase, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Phrase, name)
    __repr__ = _swig_repr
    DEFAULT_DIMENSION = _xmm.Phrase_DEFAULT_DIMENSION
    ALLOC_BLOCKSIZE = _xmm.Phrase_ALLOC_BLOCKSIZE

    def __init__(self, *args):
        """
        xmm::Phrase::Phrase(Phrase const &src)

        Copy Constructor.

        Parameters:
        -----------

        src:  source Phrase 
        """
        this = _xmm.new_Phrase(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_Phrase
    __del__ = lambda self: None

    def is_empty(self):
        """
        bool
        xmm::Phrase::is_empty() const

        Checks if the phrase is empty (length 0) 
        """
        return _xmm.Phrase_is_empty(self)


    def __eq__(self, src):
        return _xmm.Phrase___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Phrase___ne__(self, src)

    def length(self):
        """
        unsigned int
        xmm::Phrase::length() const

        length of the phrase 
        """
        return _xmm.Phrase_length(self)


    def trim(self, *args):
        """
        void xmm::Phrase::trim()

        trim phrase to minimal length of modalities 
        """
        return _xmm.Phrase_trim(self, *args)


    def dimension(self):
        """
        unsigned int
        xmm::Phrase::dimension() const

        total dimension of the data 
        """
        return _xmm.Phrase_dimension(self)


    def dimension_input(self):
        """
        unsigned int
        xmm::Phrase::dimension_input() const

        dimension of the input modality 
        """
        return _xmm.Phrase_dimension_input(self)


    def dimension_output(self):
        """
        unsigned int
        xmm::Phrase::dimension_output() const

        dimension of the output modality 
        """
        return _xmm.Phrase_dimension_output(self)


    def set_dimension(self, dimension):
        """
        void
        xmm::Phrase::set_dimension(unsigned int dimension)

        Set total dimension

        Parameters:
        -----------

        dimension:  target dimension

        Exceptions:
        -----------

        domain_error:  if dimension < 1 
        """
        return _xmm.Phrase_set_dimension(self, dimension)


    def set_dimension_input(self, dimension_input):
        """
        void
        xmm::Phrase::set_dimension_input(unsigned int dimension_input)

        Set dimension of the input modality

        Parameters:
        -----------

        dimension_input:  target dimension

        Exceptions:
        -----------

        runtime_error:  if the phrase is not bimodal

        invalid_argument:  if The dimension of the input modality exceeds the
        total dimension 
        """
        return _xmm.Phrase_set_dimension_input(self, dimension_input)


    def connect(self, *args):
        """
        void
        xmm::Phrase::connect(float *pointer_to_data_input, float
        *pointer_to_data_output, unsigned int length)

        Connect a Bimodal phrase to a shared container.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data_input:  pointer to the data array of the input
        modality

        pointer_to_data_output:  pointer to the data array of the output
        modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect(self, *args)


    def connect_input(self, pointer_to_data, length):
        """
        void
        xmm::Phrase::connect_input(float *pointer_to_data, unsigned int
        length)

        Connect a Bimodal phrase to a shared container for the input modality.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data:  pointer to the data array of the input modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect_input(self, pointer_to_data, length)


    def connect_output(self, pointer_to_data, length):
        """
        void
        xmm::Phrase::connect_output(float *pointer_to_data, unsigned int
        length)

        Connect a Bimodal phrase to a shared container for the output
        modality.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data:  pointer to the data array of the output modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect_output(self, pointer_to_data, length)


    def disconnect(self):
        """
        void
        xmm::Phrase::disconnect()

        Disconnect a phrase from a shared container.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_disconnect(self)


    def record(self, observation):
        """
        void
        xmm::Phrase::record(std::vector< float > const &observation)

        Record observation.

        Appends the observation vector observation to the data array. This
        method is only usable in Own Memory (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_record(self, observation)


    def record_input(self, observation):
        """
        void
        xmm::Phrase::record_input(std::vector< float > const &observation)

        Record observation on input modality Appends the observation vector
        observation to the data array This method is only usable in Own Memory
        (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (ownData == false) 
        """
        return _xmm.Phrase_record_input(self, observation)


    def record_output(self, observation):
        """
        void
        xmm::Phrase::record_output(std::vector< float > const &observation)

        Record observation on output modality Appends the observation vector
        observation to the data array This method is only usable in Own Memory
        (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_record_output(self, observation)


    def clear(self):
        """
        void xmm::Phrase::clear()

        Reset length of the phrase to 0 ==> empty phrase .

        WARNING:  the memory is not released (only done in destructor).

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_clear(self)


    def at(self, index, dim):
        """
        float
        xmm::Phrase::at(unsigned int index, unsigned int dim) const

        Access data at a given time index and dimension.

        Parameters:
        -----------

        index:  time index

        dim:  dimension considered, indexed from 0 to the total dimension of
        the data across modalities

        Exceptions:
        -----------

        out_of_range:  if time index or dimension are out of bounds 
        """
        return _xmm.Phrase_at(self, index, dim)


    def __call__(self, index, dim):
        return _xmm.Phrase___call__(self, index, dim)

    def get_dataPointer(self, index):
        """
        float *
        xmm::Phrase::get_dataPointer(unsigned int index) const

        Get pointer to the data at a given time index.

        Parameters:
        -----------

        index:  time index

        WARNING:  this method can be used only for unimodal phrases (no
        BIMODAL flag)

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is bimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer(self, index)


    def get_dataPointer_input(self, index):
        """
        float *
        xmm::Phrase::get_dataPointer_input(unsigned int index) const

        Get pointer to the data at a given time index for the input modality.

        WARNING:  this method can be used only for bimodal phrases
        (construction with BIMODAL flag)

        Parameters:
        -----------

        index:  time index

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is unimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer_input(self, index)


    def get_dataPointer_output(self, index):
        """
        float *
        xmm::Phrase::get_dataPointer_output(unsigned int index) const

        Get pointer to the data at a given time index for the output modality.

        WARNING:  this method can be used only for bimodal phrases
        (construction with BIMODAL flag)

        Parameters:
        -----------

        index:  time index

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is unimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer_output(self, index)


    def to_json(self):
        """
        JSONNode
        xmm::Phrase::to_json() const

        Write to JSON Node.

        JSON Node containing phrase information 
        """
        return _xmm.Phrase_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::Phrase::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.Phrase_from_json(self, root)


    def mean(self):
        """
        std::vector< float >
        xmm::Phrase::mean() const

        Compute the mean of the data phrase along the time axis.

        mean of the phrase (along time axis, full-size) 
        """
        return _xmm.Phrase_mean(self)


    def variance(self):
        """
        std::vector< float >
        xmm::Phrase::variance() const

        Compute the variance of the data phrase along the time axis.

        variance of the phrase (along time axis, full-size) 
        """
        return _xmm.Phrase_variance(self)

    __swig_setmethods__["column_names_"] = _xmm.Phrase_column_names__set
    __swig_getmethods__["column_names_"] = _xmm.Phrase_column_names__get
    if _newclass:
        column_names_ = _swig_property(_xmm.Phrase_column_names__get, _xmm.Phrase_column_names__set)
Phrase_swigregister = _xmm.Phrase_swigregister
Phrase_swigregister(Phrase)

class Label(Writable):
    """


    Label of a data phrase.

    Possible types are int and string

    C++ includes: label.h 
    """

    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Label, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Label, name)
    __repr__ = _swig_repr
    INT = _xmm.Label_INT
    SYM = _xmm.Label_SYM
    __swig_setmethods__["type"] = _xmm.Label_type_set
    __swig_getmethods__["type"] = _xmm.Label_type_get
    if _newclass:
        type = _swig_property(_xmm.Label_type_get, _xmm.Label_type_set)
    __swig_destroy__ = _xmm.delete_Label
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        xmm::Label::Label(Label
        const &src)

        Copy Constructor. 
        """
        this = _xmm.new_Label(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __eq__(self, src):
        return _xmm.Label___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Label___ne__(self, src)

    def __lt__(self, src):
        return _xmm.Label___lt__(self, src)

    def __le__(self, src):
        return _xmm.Label___le__(self, src)

    def __gt__(self, src):
        return _xmm.Label___gt__(self, src)

    def __ge__(self, src):
        return _xmm.Label___ge__(self, src)

    def getInt(self):
        """
        int xmm::Label::getInt()
        const

        Get integer label value.

        Exceptions:
        -----------

        runtime_error:  if label type is not INT

        integer label 
        """
        return _xmm.Label_getInt(self)


    def getSym(self):
        """
        std::string
        xmm::Label::getSym() const

        Get symbolic label value.

        Exceptions:
        -----------

        runtime_error:  if label type is not SYM

        symbolic label 
        """
        return _xmm.Label_getSym(self)


    def setInt(self, l):
        """
        void
        xmm::Label::setInt(int l)

        Set integer label value => sets label type to INT.

        Parameters:
        -----------

        l:  integer label 
        """
        return _xmm.Label_setInt(self, l)


    def trySetInt(self, l):
        """
        bool
        xmm::Label::trySetInt(std::string l)

        Try to set an integer from a string that contains one.

        Parameters:
        -----------

        l:  integer label stored in a string

        true if the integer label could be set 
        """
        return _xmm.Label_trySetInt(self, l)


    def setSym(self, *args):
        """
        void
        xmm::Label::setSym(char *l)

        Set symbolic label value => sets label type to SYM.

        Parameters:
        -----------

        l:  symbolic label as C-string 
        """
        return _xmm.Label_setSym(self, *args)


    def to_json(self):
        """
        JSONNode
        xmm::Label::to_json() const

        Write to JSON Node.

        JSON Node containing the label information 
        """
        return _xmm.Label_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::Label::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing the label information 
        """
        return _xmm.Label_from_json(self, root)


    def as_string(self):
        """
        std::string
        xmm::Label::as_string() const

        print label as c++ std::string 
        """
        return _xmm.Label_as_string(self)

Label_swigregister = _xmm.Label_swigregister
Label_swigregister(Label)


def is_number(s):
    """
    bool xmm::is_number(const
    std::string &s)

    Check if the string contains an integer.

    Parameters:
    -----------

    s:  std::string to check

    true if the string contains an integer 
    """
    return _xmm.is_number(s)

def to_int(s):
    """
    int xmm::to_int(const std::string
    &s)

    Get integer from string. 
    """
    return _xmm.to_int(s)

def __lshift__(stream, l):
    return _xmm.__lshift__(stream, l)
__lshift__ = _xmm.__lshift__
class TrainingSet(Writable):
    """


    Base class for the definition of (multimodal) training sets.

    Todo Needs more details

    C++ includes: training_set.h 
    """

    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """xmm::TrainingSet::TrainingSet(TrainingSet const &src) """
        this = _xmm.new_TrainingSet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_TrainingSet
    __del__ = lambda self: None

    def __eq__(self, src):
        return _xmm.TrainingSet___eq__(self, src)

    def __ne__(self, src):
        return _xmm.TrainingSet___ne__(self, src)

    def is_bimodal(self):
        """
        bool
        xmm::TrainingSet::is_bimodal() const

        checks if the training set is bimodal

        true if the training set is bimodal (construction with BIMODAL flag)

        """
        return _xmm.TrainingSet_is_bimodal(self)


    def is_empty(self):
        """
        bool
        xmm::TrainingSet::is_empty() const

        checks if the training set is empty

        true if the training set is empty (no training phrases) 
        """
        return _xmm.TrainingSet_is_empty(self)


    def add_listener(self, listener):
        """
        void
        xmm::TrainingSet::add_listener(Listener *listener)

        Add a listener to the training set. The listeners are notified when an
        attribute (e.g. dimension) of the training set is modified.

        Parameters:
        -----------

        listener:  listener model 
        """
        return _xmm.TrainingSet_add_listener(self, listener)


    def remove_listener(self, listener):
        """
        void
        xmm::TrainingSet::remove_listener(Listener *listener)

        Remove a listener form the training set.

        Parameters:
        -----------

        listener:  listener model 
        """
        return _xmm.TrainingSet_remove_listener(self, listener)


    def has_changed(self):
        """
        bool
        xmm::TrainingSet::has_changed()

        check if the training data has changed.

        true is the training data or attributes have changed 
        """
        return _xmm.TrainingSet_has_changed(self)


    def set_unchanged(self):
        """
        void
        xmm::TrainingSet::set_unchanged()

        set the status of the training set to unchanged 
        """
        return _xmm.TrainingSet_set_unchanged(self)


    def size(self):
        """
        unsigned int
        xmm::TrainingSet::size() const

        Size of the training set.

        size of the training set (number of phrases) 
        """
        return _xmm.TrainingSet_size(self)


    def dimension(self):
        """
        unsigned int
        xmm::TrainingSet::dimension() const

        Get total dimension of the training data.

        dimension of the training data 
        """
        return _xmm.TrainingSet_dimension(self)


    def dimension_input(self):
        """
        unsigned
        int xmm::TrainingSet::dimension_input() const

        Get dimension of the input modality in bimodal mode.

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if the phrase is unimodal (no BIMODAL construction
        flag) 
        """
        return _xmm.TrainingSet_dimension_input(self)


    def set_dimension(self, dimension):
        """
        void
        xmm::TrainingSet::set_dimension(unsigned int dimension)

        Set total dimension of the training data.

        Parameters:
        -----------

        dimension:  dimension of the training data

        Exceptions:
        -----------

        out_of_range:  if the dimension is < 1 
        """
        return _xmm.TrainingSet_set_dimension(self, dimension)


    def set_dimension_input(self, dimension_input):
        """
        void
        xmm::TrainingSet::set_dimension_input(unsigned int dimension_input)

        Set the dimension of the input modality in bimodal mode.

        Parameters:
        -----------

        dimension_input:  dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if the phrase is not bimodal

        invalid_argument:  if The dimension of the input modality exceeds the
        total dimension 
        """
        return _xmm.TrainingSet_set_dimension_input(self, dimension_input)


    def set_column_names(self, colnames):
        """
        void
        xmm::TrainingSet::set_column_names(std::vector< std::string > const
        &colnames)

        set the column names of the Training Set 
        """
        return _xmm.TrainingSet_set_column_names(self, colnames)


    def get_column_names(self):
        """
        std::vector< std::string > const &
        xmm::TrainingSet::get_column_names() const

        get a copy of the column names of the Training Set 
        """
        return _xmm.TrainingSet_get_column_names(self)


    def begin(self):
        """
        xmm::TrainingSet::phrase_iterator xmm::TrainingSet::begin()

        iterator to the beginning of phrases 
        """
        return _xmm.TrainingSet_begin(self)


    def end(self):
        """
        xmm::TrainingSet::phrase_iterator xmm::TrainingSet::end()

        iterator to the end of phrases 
        """
        return _xmm.TrainingSet_end(self)


    def cbegin(self):
        """
        xmm::TrainingSet::const_phrase_iterator xmm::TrainingSet::cbegin()
        const

        constant iterator to the beginning of phrases 
        """
        return _xmm.TrainingSet_cbegin(self)


    def cend(self):
        """
        xmm::TrainingSet::const_phrase_iterator xmm::TrainingSet::cend() const

        constant iterator to the end of phrases 
        """
        return _xmm.TrainingSet_cend(self)


    def __call__(self, n):
        return _xmm.TrainingSet___call__(self, n)

    def connect(self, *args):
        """
        void
        xmm::TrainingSet::connect(int phraseIndex, float
        *pointer_to_data_input, float *pointer_to_data_output, unsigned int
        length)

        Connect a phrase to the training set (synchronous bimodal case)

        This method is used in shared memory to pass an array to the training
        set. If the phrase does not exist, it is created at the specified
        index.

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set. If it does not
        exist, the phrase is created.

        pointer_to_data_input:  pointer to the data array for the input
        modality

        pointer_to_data_output:  pointer to the data array for the output
        modality

        length:  length of the phrase

        Exceptions:
        -----------

        runtime_error:  if not in shared memory (construction with
        SHARED_MEMORY flag)

        runtime_error:  if bimodal (construction with the BIMODAL flag) 
        """
        return _xmm.TrainingSet_connect(self, *args)


    def recordPhrase(self, phraseIndex, observation):
        """
        void
        xmm::TrainingSet::recordPhrase(int phraseIndex, std::vector< float >
        const &observation)

        Record training data.

        The method appends an observation to the data phrase. The observation
        need to have a size "dimension". In bimodal mode, the observation
        must concatenate input and output observations. A phrase is created if
        it does not exists at the given index

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector to append to the phrase

        Exceptions:
        -----------

        runtime_errpr:  if phrase has shared memory (construction with
        SHARED_MEMORY flag) 
        """
        return _xmm.TrainingSet_recordPhrase(self, phraseIndex, observation)


    def recordPhrase_input(self, phraseIndex, observation):
        """
        void
        xmm::TrainingSet::recordPhrase_input(int phraseIndex, std::vector<
        float > const &observation)

        Record training data on the input modality.

        The method appends an observation on the input modality to the data
        phrase. size "dimension_input"

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (ownData == false) 
        """
        return _xmm.TrainingSet_recordPhrase_input(self, phraseIndex, observation)


    def recordPhrase_output(self, phraseIndex, observation):
        """
        void
        xmm::TrainingSet::recordPhrase_output(int phraseIndex, std::vector<
        float > const &observation)

        Record training data on the output modality Appends the observation
        vector observation to the data array This method is only usable in Own
        Memory (no SHARED_MEMORY flag)

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.TrainingSet_recordPhrase_output(self, phraseIndex, observation)


    def resetPhrase(self, phraseIndex):
        """
        void
        xmm::TrainingSet::resetPhrase(int phraseIndex)

        reset phrase to default

        The phrase is set to an empty phrase with the current attributes
        (dimensions, etc). The phrase is created if it does not exists at the
        given index.

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet 
        """
        return _xmm.TrainingSet_resetPhrase(self, phraseIndex)


    def deletePhrase(self, phraseIndex):
        """
        void
        xmm::TrainingSet::deletePhrase(int phraseIndex)

        delete a phrase

        WARNING:  if the training set is locked, the phrase iself is not
        deleted (only the reference), i.e. its memory is not released.

        Parameters:
        -----------

        phraseIndex:  index of the phrase

        Exceptions:
        -----------

        out_of_bounds:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_deletePhrase(self, phraseIndex)


    def deletePhrasesOfClass(self, label):
        """
        void
        xmm::TrainingSet::deletePhrasesOfClass(Label const &label)

        delete all phrases of a given class

        WARNING:  if the training set is locked, the phrases themselves are
        not deleted (only the references), i.e. their memory is not released.

        Parameters:
        -----------

        label:  label of the class to delete

        Exceptions:
        -----------

        out_of_bounds:  if the label does not exist 
        """
        return _xmm.TrainingSet_deletePhrasesOfClass(self, label)


    def deleteEmptyPhrases(self):
        """
        void
        xmm::TrainingSet::deleteEmptyPhrases()

        delete all empty phrases 
        """
        return _xmm.TrainingSet_deleteEmptyPhrases(self)


    def clear(self):
        """
        void
        xmm::TrainingSet::clear()

        delete all phrases

        WARNING:  if the training set is locked, the phrases themselves are
        not deleted (only their references), i.e. their memory is not
        released. 
        """
        return _xmm.TrainingSet_clear(self)


    def setDefaultLabel(self, defLabel):
        """
        void
        xmm::TrainingSet::setDefaultLabel(Label const &defLabel)

        set default phrase label for new phrases

        Parameters:
        -----------

        defLabel:  default Label 
        """
        return _xmm.TrainingSet_setDefaultLabel(self, defLabel)


    def setPhraseLabelToDefault(self, phraseIndex):
        """
        void xmm::TrainingSet::setPhraseLabelToDefault(int phraseIndex)

        set label of a phrase to default

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        Exceptions:
        -----------

        out_of_range:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_setPhraseLabelToDefault(self, phraseIndex)


    def setPhraseLabel(self, phraseIndex, label):
        """
        void
        xmm::TrainingSet::setPhraseLabel(int phraseIndex, Label const &label)

        set the label of a phrase

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        label:  label to set

        Exceptions:
        -----------

        out_of_range:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_setPhraseLabel(self, phraseIndex, label)


    def getPhraseLabel(self, phraseIndex):
        """
        xmm::Label
        xmm::TrainingSet::getPhraseLabel(int phraseIndex)

        get the current label of a phrase in the training set

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        label of the phrase 
        """
        return _xmm.TrainingSet_getPhraseLabel(self, phraseIndex)


    def getSubTrainingSetForClass(self, label):
        """
        xmm::TrainingSet * xmm::TrainingSet::getSubTrainingSetForClass(Label
        const &label)

        get the pointer to the sub-training set containing all phrases with a
        given label

        WARNING:  in order to protect the phrases in the current training set,
        the sub- training set returned is locked

        Parameters:
        -----------

        label:  target label

        pointer to the sub-training set containing all phrases with a given
        label

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm.TrainingSet_getSubTrainingSetForClass(self, label)


    def updateSubTrainingSets(self):
        """
        void
        xmm::TrainingSet::updateSubTrainingSets()

        create all the sub-training sets: one for each label

        each subset contains only the phrase for the given label 
        """
        return _xmm.TrainingSet_updateSubTrainingSets(self)


    def mean(self):
        """
        std::vector< float >
        xmm::TrainingSet::mean() const

        Compute the global mean of all data phrases along the time axis.

        global mean of all phrases (along time axis, full-size) 
        """
        return _xmm.TrainingSet_mean(self)


    def variance(self):
        """
        std::vector< float
        > xmm::TrainingSet::variance() const

        Compute the global variance of all data phrases along the time axis.

        global variance of all phrases (along time axis, full-size) 
        """
        return _xmm.TrainingSet_variance(self)


    def to_json(self):
        """
        JSONNode
        xmm::TrainingSet::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.TrainingSet_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::TrainingSet::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.TrainingSet_from_json(self, root)

    __swig_setmethods__["phrases"] = _xmm.TrainingSet_phrases_set
    __swig_getmethods__["phrases"] = _xmm.TrainingSet_phrases_get
    if _newclass:
        phrases = _swig_property(_xmm.TrainingSet_phrases_get, _xmm.TrainingSet_phrases_set)
    __swig_setmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_set
    __swig_getmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_get
    if _newclass:
        phraseLabels = _swig_property(_xmm.TrainingSet_phraseLabels_get, _xmm.TrainingSet_phraseLabels_set)
    __swig_setmethods__["allLabels"] = _xmm.TrainingSet_allLabels_set
    __swig_getmethods__["allLabels"] = _xmm.TrainingSet_allLabels_get
    if _newclass:
        allLabels = _swig_property(_xmm.TrainingSet_allLabels_get, _xmm.TrainingSet_allLabels_set)
TrainingSet_swigregister = _xmm.TrainingSet_swigregister
TrainingSet_swigregister(TrainingSet)

class EMStopCriterion(_object):
    """


    Stop Criterion for the EM algorithm.

    C++ includes: probabilistic_model.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EMStopCriterion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EMStopCriterion, name)
    __repr__ = _swig_repr
    __swig_setmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_set
    __swig_getmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_get
    if _newclass:
        minSteps = _swig_property(_xmm.EMStopCriterion_minSteps_get, _xmm.EMStopCriterion_minSteps_set)
    __swig_setmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_set
    __swig_getmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_get
    if _newclass:
        maxSteps = _swig_property(_xmm.EMStopCriterion_maxSteps_get, _xmm.EMStopCriterion_maxSteps_set)
    __swig_setmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_set
    __swig_getmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_get
    if _newclass:
        percentChg = _swig_property(_xmm.EMStopCriterion_percentChg_get, _xmm.EMStopCriterion_percentChg_set)

    def __init__(self):
        this = _xmm.new_EMStopCriterion()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_EMStopCriterion
    __del__ = lambda self: None
EMStopCriterion_swigregister = _xmm.EMStopCriterion_swigregister
EMStopCriterion_swigregister(EMStopCriterion)

class ProbabilisticModel(Listener, Writable):
    """


    Generic Template for Machine Learning Probabilistic models based on
    the EM algorithm.

    C++ includes: probabilistic_model.h 
    """

    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProbabilisticModel, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProbabilisticModel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    TRAINING_RUN = _xmm.ProbabilisticModel_TRAINING_RUN
    TRAINING_DONE = _xmm.ProbabilisticModel_TRAINING_DONE
    TRAINING_ERROR = _xmm.ProbabilisticModel_TRAINING_ERROR
    TRAINING_ABORT = _xmm.ProbabilisticModel_TRAINING_ABORT
    TRAINING_ALLDONE = _xmm.ProbabilisticModel_TRAINING_ALLDONE
    DEFAULT_EMSTOP_MINSTEPS = _xmm.ProbabilisticModel_DEFAULT_EMSTOP_MINSTEPS
    DEFAULT_EMSTOP_MAXSTEPS = _xmm.ProbabilisticModel_DEFAULT_EMSTOP_MAXSTEPS
    __swig_getmethods__["DEFAULT_EMSTOP_PERCENT_CHG"] = lambda x: _xmm.ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG
    if _newclass:
        DEFAULT_EMSTOP_PERCENT_CHG = staticmethod(_xmm.ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG)
    DEFAULT_LIKELIHOOD_WINDOW = _xmm.ProbabilisticModel_DEFAULT_LIKELIHOOD_WINDOW
    DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS = _xmm.ProbabilisticModel_DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS
    __swig_destroy__ = _xmm.delete_ProbabilisticModel
    __del__ = lambda self: None

    def is_training(self):
        """
        bool
        xmm::ProbabilisticModel::is_training() const

        Checks if the model is training.

        true if the model is training 
        """
        return _xmm.ProbabilisticModel_is_training(self)


    def set_trainingSet(self, trainingSet):
        """
        void
        xmm::ProbabilisticModel::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the dimensions of the model

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.ProbabilisticModel_set_trainingSet(self, trainingSet)


    def dimension(self):
        """
        unsigned
        int xmm::ProbabilisticModel::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm.ProbabilisticModel_dimension(self)


    def dimension_input(self):
        """
        unsigned int xmm::ProbabilisticModel::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm.ProbabilisticModel_dimension_input(self)


    def get_likelihoodwindow(self):
        """
        unsigned int xmm::ProbabilisticModel::get_likelihoodwindow() const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm.ProbabilisticModel_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void xmm::ProbabilisticModel::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm.ProbabilisticModel_set_likelihoodwindow(self, likelihoodwindow)


    def get_column_names(self):
        """
        std::vector< std::string > const &
        xmm::ProbabilisticModel::get_column_names() const

        get a copy of the column names of the input/output data 
        """
        return _xmm.ProbabilisticModel_get_column_names(self)


    def train(self):
        """
        void
        xmm::ProbabilisticModel::train()

        Main training method based on the EM algorithm.

        the method performs a loop over the pure virtual method
        train_EM_update() until convergence. The train_EM_update method
        computes both E and M steps of the EM algorithm. See:  train_EM_update

        """
        return _xmm.ProbabilisticModel_train(self)


    def abortTraining(self, this_thread):
        return _xmm.ProbabilisticModel_abortTraining(self, this_thread)

    def set_trainingCallback(self, callback, extradata):
        """
        void
        xmm::ProbabilisticModel::set_trainingCallback(void(*callback)(void
        *srcModel, CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm.ProbabilisticModel_set_trainingCallback(self, callback, extradata)

    __swig_getmethods__["train_func"] = lambda x: _xmm.ProbabilisticModel_train_func
    if _newclass:
        train_func = staticmethod(_xmm.ProbabilisticModel_train_func)

    def performance_init(self):
        """
        void xmm::ProbabilisticModel::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.ProbabilisticModel_performance_init(self)


    def performance_update(self, observation):
        """
        virtual double
        xmm::ProbabilisticModel::performance_update(std::vector< float > const
        &observation)=0

        Main Play function: updates the predictions of the model given a new
        observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension' or
        'dimension_input' depending on the mode [unimodal/bimodal])

        likelihood of the observation 
        """
        return _xmm.ProbabilisticModel_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        xmm::ProbabilisticModel::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.ProbabilisticModel_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::ProbabilisticModel::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.ProbabilisticModel_from_json(self, root)

    __swig_setmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_set
    __swig_getmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_get
    if _newclass:
        trainingSet = _swig_property(_xmm.ProbabilisticModel_trainingSet_get, _xmm.ProbabilisticModel_trainingSet_set)
    __swig_setmethods__["trained"] = _xmm.ProbabilisticModel_trained_set
    __swig_getmethods__["trained"] = _xmm.ProbabilisticModel_trained_get
    if _newclass:
        trained = _swig_property(_xmm.ProbabilisticModel_trained_get, _xmm.ProbabilisticModel_trained_set)
    __swig_setmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_set
    __swig_getmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_get
    if _newclass:
        stopcriterion = _swig_property(_xmm.ProbabilisticModel_stopcriterion_get, _xmm.ProbabilisticModel_stopcriterion_set)
    __swig_setmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_set
    __swig_getmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_get
    if _newclass:
        trainingProgression = _swig_property(_xmm.ProbabilisticModel_trainingProgression_get, _xmm.ProbabilisticModel_trainingProgression_set)
    __swig_setmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_set
    __swig_getmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_get
    if _newclass:
        results_instant_likelihood = _swig_property(_xmm.ProbabilisticModel_results_instant_likelihood_get, _xmm.ProbabilisticModel_results_instant_likelihood_set)
    __swig_setmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_set
    __swig_getmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_get
    if _newclass:
        results_log_likelihood = _swig_property(_xmm.ProbabilisticModel_results_log_likelihood_get, _xmm.ProbabilisticModel_results_log_likelihood_set)
    __swig_setmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm.ProbabilisticModel_results_predicted_output_get, _xmm.ProbabilisticModel_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm.ProbabilisticModel_results_output_variance_get, _xmm.ProbabilisticModel_results_output_variance_set)
    __swig_setmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_set
    __swig_getmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_get
    if _newclass:
        trainingLogLikelihood = _swig_property(_xmm.ProbabilisticModel_trainingLogLikelihood_get, _xmm.ProbabilisticModel_trainingLogLikelihood_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.ProbabilisticModel_trainingNbIterations_get, _xmm.ProbabilisticModel_trainingNbIterations_set)
ProbabilisticModel_swigregister = _xmm.ProbabilisticModel_swigregister
ProbabilisticModel_swigregister(ProbabilisticModel)

def ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG():
    return _xmm.ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG()
ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG = _xmm.ProbabilisticModel_DEFAULT_EMSTOP_PERCENT_CHG

def ProbabilisticModel_train_func(context):
    return _xmm.ProbabilisticModel_train_func(context)
ProbabilisticModel_train_func = _xmm.ProbabilisticModel_train_func

class Ellipse(_object):
    """


    Simple structure for storing Ellipse parameters.

    C++ includes: gaussian_distribution.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Ellipse, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Ellipse, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _xmm.Ellipse_x_set
    __swig_getmethods__["x"] = _xmm.Ellipse_x_get
    if _newclass:
        x = _swig_property(_xmm.Ellipse_x_get, _xmm.Ellipse_x_set)
    __swig_setmethods__["y"] = _xmm.Ellipse_y_set
    __swig_getmethods__["y"] = _xmm.Ellipse_y_get
    if _newclass:
        y = _swig_property(_xmm.Ellipse_y_get, _xmm.Ellipse_y_set)
    __swig_setmethods__["width"] = _xmm.Ellipse_width_set
    __swig_getmethods__["width"] = _xmm.Ellipse_width_get
    if _newclass:
        width = _swig_property(_xmm.Ellipse_width_get, _xmm.Ellipse_width_set)
    __swig_setmethods__["height"] = _xmm.Ellipse_height_set
    __swig_getmethods__["height"] = _xmm.Ellipse_height_get
    if _newclass:
        height = _swig_property(_xmm.Ellipse_height_get, _xmm.Ellipse_height_set)
    __swig_setmethods__["angle"] = _xmm.Ellipse_angle_set
    __swig_getmethods__["angle"] = _xmm.Ellipse_angle_get
    if _newclass:
        angle = _swig_property(_xmm.Ellipse_angle_get, _xmm.Ellipse_angle_set)

    def __init__(self):
        this = _xmm.new_Ellipse()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_Ellipse
    __del__ = lambda self: None
Ellipse_swigregister = _xmm.Ellipse_swigregister
Ellipse_swigregister(Ellipse)

class GaussianDistribution(Writable):
    """


    Multivariate Gaussian Distribution.

    Full covariance, optionally multimodal with support for regression

    C++ includes: gaussian_distribution.h 
    """

    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianDistribution, name)
    __repr__ = _swig_repr

    def DEFAULT_VARIANCE_OFFSET_RELATIVE():
        """
        static
        const double
        xmm::GaussianDistribution::DEFAULT_VARIANCE_OFFSET_RELATIVE()

        default offset for covariance matrix 
        """
        return _xmm.GaussianDistribution_DEFAULT_VARIANCE_OFFSET_RELATIVE()

    if _newclass:
        DEFAULT_VARIANCE_OFFSET_RELATIVE = staticmethod(DEFAULT_VARIANCE_OFFSET_RELATIVE)
    __swig_getmethods__["DEFAULT_VARIANCE_OFFSET_RELATIVE"] = lambda x: DEFAULT_VARIANCE_OFFSET_RELATIVE

    def DEFAULT_VARIANCE_OFFSET_ABSOLUTE():
        """
        static
        const double
        xmm::GaussianDistribution::DEFAULT_VARIANCE_OFFSET_ABSOLUTE() 
        """
        return _xmm.GaussianDistribution_DEFAULT_VARIANCE_OFFSET_ABSOLUTE()

    if _newclass:
        DEFAULT_VARIANCE_OFFSET_ABSOLUTE = staticmethod(DEFAULT_VARIANCE_OFFSET_ABSOLUTE)
    __swig_getmethods__["DEFAULT_VARIANCE_OFFSET_ABSOLUTE"] = lambda x: DEFAULT_VARIANCE_OFFSET_ABSOLUTE
    FULL = _xmm.GaussianDistribution_FULL
    DIAGONAL = _xmm.GaussianDistribution_DIAGONAL

    def __init__(self, *args):
        """
        xmm::GaussianDistribution::GaussianDistribution(GaussianDistribution
        const &src)

        Copy constructor.

        Parameters:
        -----------

        src:  source distribution 
        """
        this = _xmm.new_GaussianDistribution(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_GaussianDistribution
    __del__ = lambda self: None

    def dimension(self):
        """
        unsigned
        int xmm::GaussianDistribution::dimension() const

        Get Dimension of the distribution.

        dimension 
        """
        return _xmm.GaussianDistribution_dimension(self)


    def set_dimension(self, dimension):
        """
        void
        xmm::GaussianDistribution::set_dimension(unsigned int dimension)

        Set Dimension of the distribution. 
        """
        return _xmm.GaussianDistribution_set_dimension(self, dimension)


    def dimension_input(self):
        """
        unsigned int xmm::GaussianDistribution::dimension_input() const

        Get Dimension of the input modality.

        dimension 
        """
        return _xmm.GaussianDistribution_dimension_input(self)


    def set_dimension_input(self, dimension_input):
        """
        void xmm::GaussianDistribution::set_dimension_input(unsigned int
        dimension_input)

        Set Dimension of the input modality.

        Parameters:
        -----------

        dimension_input:  dimension of the input modality

        Exceptions:
        -----------

        out_of_range:  if the dimension is superior to the total dimension 
        """
        return _xmm.GaussianDistribution_set_dimension_input(self, dimension_input)


    def get_covariance_mode(self):
        """
        xmm::GaussianDistribution::COVARIANCE_MODE
        xmm::GaussianDistribution::get_covariance_mode() const

        get the current covariance mode 
        """
        return _xmm.GaussianDistribution_get_covariance_mode(self)


    def set_covariance_mode(self, covariance_mode):
        """
        void xmm::GaussianDistribution::set_covariance_mode(COVARIANCE_MODE
        covariance_mode)

        set the covariance mode

        Parameters:
        -----------

        covariance_mode:  target covariance mode 
        """
        return _xmm.GaussianDistribution_set_covariance_mode(self, covariance_mode)


    def likelihood(self, observation):
        """
        double
        xmm::GaussianDistribution::likelihood(const float *observation) const

        Get Likelihood of a data vector.

        Parameters:
        -----------

        observation:  data observation (must be of size dimension)

        likelihood

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix is not invertible 
        """
        return _xmm.GaussianDistribution_likelihood(self, observation)


    def likelihood_input(self, observation_input):
        """
        double xmm::GaussianDistribution::likelihood_input(const float
        *observation_input) const

        Get Likelihood of a data vector for input modality.

        Parameters:
        -----------

        observation_input:  observation (must be of size dimension_input)

        likelihood

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix of the input modality is not
        invertible

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_likelihood_input(self, observation_input)


    def likelihood_bimodal(self, observation_input, observation_output):
        """
        double xmm::GaussianDistribution::likelihood_bimodal(const float
        *observation_input, const float *observation_output) const

        Get Likelihood of a data vector for bimodal mode.

        Parameters:
        -----------

        observation_input:  observation of the input modality

        observation_output:  observation of the output modality

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix is not invertible

        runtime_error:  if the model is not bimodal

        likelihood 
        """
        return _xmm.GaussianDistribution_likelihood_bimodal(self, observation_input, observation_output)


    def regression(self, observation_input, predicted_output):
        """
        void
        xmm::GaussianDistribution::regression(std::vector< float > const
        &observation_input, std::vector< float > &predicted_output) const

        Linear Regression using the Gaussian Distribution (covariance-based)

        Parameters:
        -----------

        observation_input:  input observation (must be of size:
        dimension_input)

        predicted_output:  predicted output vector (size: dimension-
        dimension_input)

        Exceptions:
        -----------

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_regression(self, observation_input, predicted_output)


    def to_json(self):
        """
        JSONNode
        xmm::GaussianDistribution::to_json() const

        Write to JSON Node.

        The JSON Node containing the Gaussian Distribution parameters 
        """
        return _xmm.GaussianDistribution_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::GaussianDistribution::from_json(JSONNode root)

        Write to JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.GaussianDistribution_from_json(self, root)


    def addOffset(self):
        """
        void
        xmm::GaussianDistribution::addOffset()

        Add offset to the diagonal of the covariance matrix.

        Ensures convergence + generalization on few examples 
        """
        return _xmm.GaussianDistribution_addOffset(self)


    def updateInverseCovariance(self):
        """
        void
        xmm::GaussianDistribution::updateInverseCovariance()

        Compute inverse covariance matrix.

        Exceptions:
        -----------

        runtime_error:  if the covariance matrix is not invertible 
        """
        return _xmm.GaussianDistribution_updateInverseCovariance(self)


    def updateOutputVariances(self):
        """
        void
        xmm::GaussianDistribution::updateOutputVariances()

        Compute the conditional variance vector of the output modality
        (conditioned over the input).

        Exceptions:
        -----------

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_updateOutputVariances(self)


    def ellipse(self, dimension1, dimension2):
        """
        xmm::Ellipse xmm::GaussianDistribution::ellipse(unsigned int
        dimension1, unsigned int dimension2)

        Compute the 95% Confidence Interval ellipse of the Gaussian.

        the ellipse is 2D, and is therefore projected over 2 axes

        Parameters:
        -----------

        dimension1:  index of the first axis

        dimension2:  index of the second axis

        Exceptions:
        -----------

        out_of_range:  if the dimensions are out of bounds

        ellipse parameters 
        """
        return _xmm.GaussianDistribution_ellipse(self, dimension1, dimension2)


    def make_bimodal(self, dimension_input):
        """
        void
        xmm::GaussianDistribution::make_bimodal(unsigned int dimension_input)

        Convert to bimodal distribution in place.

        Parameters:
        -----------

        dimension_input:  dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if the model is already bimodal

        out_of_range:  if the requested input dimension is too large 
        """
        return _xmm.GaussianDistribution_make_bimodal(self, dimension_input)


    def make_unimodal(self):
        """
        void
        xmm::GaussianDistribution::make_unimodal()

        Convert to unimodal distribution in place.

        Exceptions:
        -----------

        runtime_error:  if the model is already unimodal 
        """
        return _xmm.GaussianDistribution_make_unimodal(self)


    def extract_submodel(self, columns):
        """
        xmm::GaussianDistribution
        xmm::GaussianDistribution::extract_submodel(std::vector< unsigned int
        > &columns) const

        extract a sub-distribution with the given columns

        Parameters:
        -----------

        columns:  columns indices in the target order

        Exceptions:
        -----------

        runtime_error:  if the model is training

        out_of_range:  if the number or indices of the requested columns
        exceeds the current dimension

        a Gaussian Distribution from the current model considering only the
        target columns 
        """
        return _xmm.GaussianDistribution_extract_submodel(self, columns)


    def extract_submodel_input(self):
        """
        xmm::GaussianDistribution
        xmm::GaussianDistribution::extract_submodel_input() const

        extract the sub-distribution of the input modality

        Exceptions:
        -----------

        runtime_error:  if the model is training or if it is not bimodal

        a unimodal Gaussian Distribution of the input modality from the
        current bimodal model 
        """
        return _xmm.GaussianDistribution_extract_submodel_input(self)


    def extract_submodel_output(self):
        """
        xmm::GaussianDistribution
        xmm::GaussianDistribution::extract_submodel_output() const

        extract the sub-distribution of the output modality

        Exceptions:
        -----------

        runtime_error:  if the model is training or if it is not bimodal

        a unimodal Gaussian Distribution of the output modality from the
        current bimodal model 
        """
        return _xmm.GaussianDistribution_extract_submodel_output(self)


    def extract_inverse_model(self):
        """
        xmm::GaussianDistribution
        xmm::GaussianDistribution::extract_inverse_model() const

        extract the model with reversed input and output modalities

        Exceptions:
        -----------

        runtime_error:  if the model is training or if it is not bimodal

        a bimodal Gaussian Distribution that swaps the input and output
        modalities 
        """
        return _xmm.GaussianDistribution_extract_inverse_model(self)

    __swig_setmethods__["mean"] = _xmm.GaussianDistribution_mean_set
    __swig_getmethods__["mean"] = _xmm.GaussianDistribution_mean_get
    if _newclass:
        mean = _swig_property(_xmm.GaussianDistribution_mean_get, _xmm.GaussianDistribution_mean_set)
    __swig_setmethods__["covariance"] = _xmm.GaussianDistribution_covariance_set
    __swig_getmethods__["covariance"] = _xmm.GaussianDistribution_covariance_get
    if _newclass:
        covariance = _swig_property(_xmm.GaussianDistribution_covariance_get, _xmm.GaussianDistribution_covariance_set)
    __swig_setmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_set
    __swig_getmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_get
    if _newclass:
        offset_relative = _swig_property(_xmm.GaussianDistribution_offset_relative_get, _xmm.GaussianDistribution_offset_relative_set)
    __swig_setmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_set
    __swig_getmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_get
    if _newclass:
        offset_absolute = _swig_property(_xmm.GaussianDistribution_offset_absolute_get, _xmm.GaussianDistribution_offset_absolute_set)
    __swig_setmethods__["scale"] = _xmm.GaussianDistribution_scale_set
    __swig_getmethods__["scale"] = _xmm.GaussianDistribution_scale_get
    if _newclass:
        scale = _swig_property(_xmm.GaussianDistribution_scale_get, _xmm.GaussianDistribution_scale_set)
    __swig_setmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_set
    __swig_getmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_get
    if _newclass:
        output_variance = _swig_property(_xmm.GaussianDistribution_output_variance_get, _xmm.GaussianDistribution_output_variance_set)
GaussianDistribution_swigregister = _xmm.GaussianDistribution_swigregister
GaussianDistribution_swigregister(GaussianDistribution)

def GaussianDistribution_DEFAULT_VARIANCE_OFFSET_RELATIVE():
    """
    static
    const double
    xmm::GaussianDistribution::DEFAULT_VARIANCE_OFFSET_RELATIVE()

    default offset for covariance matrix 
    """
    return _xmm.GaussianDistribution_DEFAULT_VARIANCE_OFFSET_RELATIVE()

def GaussianDistribution_DEFAULT_VARIANCE_OFFSET_ABSOLUTE():
    """
    static
    const double
    xmm::GaussianDistribution::DEFAULT_VARIANCE_OFFSET_ABSOLUTE() 
    """
    return _xmm.GaussianDistribution_DEFAULT_VARIANCE_OFFSET_ABSOLUTE()

class KMeans(Listener, Writable):
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr
    DEFAULT_MAX_ITERATIONS = _xmm.KMeans_DEFAULT_MAX_ITERATIONS
    __swig_getmethods__["DEFAULT_RELATIVE_VARIATION_THRESHOLD"] = lambda x: _xmm.KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD
    if _newclass:
        DEFAULT_RELATIVE_VARIATION_THRESHOLD = staticmethod(_xmm.KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD)
    RANDOM = _xmm.KMeans_RANDOM
    BIASED = _xmm.KMeans_BIASED

    def __init__(self, *args):
        this = _xmm.new_KMeans(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_KMeans
    __del__ = lambda self: None

    def set_trainingSet(self, trainingSet):
        return _xmm.KMeans_set_trainingSet(self, trainingSet)

    def dimension(self):
        return _xmm.KMeans_dimension(self)

    def get_nbClusters(self):
        return _xmm.KMeans_get_nbClusters(self)

    def set_nbClusters(self, nbClusters):
        return _xmm.KMeans_set_nbClusters(self, nbClusters)

    def get_training_maxIterations(self):
        return _xmm.KMeans_get_training_maxIterations(self)

    def set_training_maxIterations(self, maxIterations):
        return _xmm.KMeans_set_training_maxIterations(self, maxIterations)

    def get_training_relativeDistanceThreshold(self):
        return _xmm.KMeans_get_training_relativeDistanceThreshold(self)

    def set_training_relativeDistanceThreshold(self, threshold):
        return _xmm.KMeans_set_training_relativeDistanceThreshold(self, threshold)

    def train(self):
        return _xmm.KMeans_train(self)

    def randomizeClusters(self):
        return _xmm.KMeans_randomizeClusters(self)

    def set_trainingCallback(self, callback, extradata):
        return _xmm.KMeans_set_trainingCallback(self, callback, extradata)

    def performance_init(self):
        return _xmm.KMeans_performance_init(self)

    def performance_update(self, observation):
        return _xmm.KMeans_performance_update(self, observation)

    def to_json(self):
        """
        virtual JSONNode
        xmm::Writable::to_json() const  =0

        Write to JSON Node.

        JSON Node containing phrase information Todo include type attribute in
        each to_json function 
        """
        return _xmm.KMeans_to_json(self)


    def from_json(self, root):
        """
        virtual void
        xmm::Writable::from_json(JSONNode root)=0

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format

        Todo add force_conversion optional argument? 
        """
        return _xmm.KMeans_from_json(self, root)

    __swig_setmethods__["centers"] = _xmm.KMeans_centers_set
    __swig_getmethods__["centers"] = _xmm.KMeans_centers_get
    if _newclass:
        centers = _swig_property(_xmm.KMeans_centers_get, _xmm.KMeans_centers_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.KMeans_trainingNbIterations_get, _xmm.KMeans_trainingNbIterations_set)
    __swig_setmethods__["results_distances"] = _xmm.KMeans_results_distances_set
    __swig_getmethods__["results_distances"] = _xmm.KMeans_results_distances_get
    if _newclass:
        results_distances = _swig_property(_xmm.KMeans_results_distances_get, _xmm.KMeans_results_distances_set)
    __swig_setmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm.KMeans_results_likeliest_get, _xmm.KMeans_results_likeliest_set)
    __swig_setmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_set
    __swig_getmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_get
    if _newclass:
        trainingInitType = _swig_property(_xmm.KMeans_trainingInitType_get, _xmm.KMeans_trainingInitType_set)
KMeans_swigregister = _xmm.KMeans_swigregister
KMeans_swigregister(KMeans)

def KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD():
    return _xmm.KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD()
KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD = _xmm.KMeans_DEFAULT_RELATIVE_VARIATION_THRESHOLD

class GMM(ProbabilisticModel):
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMM, name)
    __repr__ = _swig_repr
    DEFAULT_NB_MIXTURE_COMPONENTS = _xmm.GMM_DEFAULT_NB_MIXTURE_COMPONENTS

    def __init__(self, *args):
        this = _xmm.new_GMM(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_GMM
    __del__ = lambda self: None

    def get_nbMixtureComponents(self):
        return _xmm.GMM_get_nbMixtureComponents(self)

    def get_varianceOffset_relative(self):
        return _xmm.GMM_get_varianceOffset_relative(self)

    def get_varianceOffset_absolute(self):
        return _xmm.GMM_get_varianceOffset_absolute(self)

    def set_nbMixtureComponents(self, nbMixtureComponents):
        return _xmm.GMM_set_nbMixtureComponents(self, nbMixtureComponents)

    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        return _xmm.GMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)

    def get_covariance_mode(self):
        return _xmm.GMM_get_covariance_mode(self)

    def set_covariance_mode(self, covariance_mode):
        return _xmm.GMM_set_covariance_mode(self, covariance_mode)

    def performance_init(self):
        """
        void xmm::ProbabilisticModel::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.GMM_performance_init(self)


    def performance_update(self, observation):
        """
        virtual double
        xmm::ProbabilisticModel::performance_update(std::vector< float > const
        &observation)=0

        Main Play function: updates the predictions of the model given a new
        observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension' or
        'dimension_input' depending on the mode [unimodal/bimodal])

        likelihood of the observation 
        """
        return _xmm.GMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        xmm::ProbabilisticModel::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.GMM_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::ProbabilisticModel::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.GMM_from_json(self, root)


    def make_bimodal(self, dimension_input):
        return _xmm.GMM_make_bimodal(self, dimension_input)

    def make_unimodal(self):
        return _xmm.GMM_make_unimodal(self)

    def extract_submodel(self, columns):
        return _xmm.GMM_extract_submodel(self, columns)

    def extract_submodel_input(self):
        return _xmm.GMM_extract_submodel_input(self)

    def extract_submodel_output(self):
        return _xmm.GMM_extract_submodel_output(self)

    def extract_inverse_model(self):
        return _xmm.GMM_extract_inverse_model(self)
    __swig_setmethods__["components"] = _xmm.GMM_components_set
    __swig_getmethods__["components"] = _xmm.GMM_components_get
    if _newclass:
        components = _swig_property(_xmm.GMM_components_get, _xmm.GMM_components_set)
    __swig_setmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_set
    __swig_getmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_get
    if _newclass:
        mixtureCoeffs = _swig_property(_xmm.GMM_mixtureCoeffs_get, _xmm.GMM_mixtureCoeffs_set)
    __swig_setmethods__["beta"] = _xmm.GMM_beta_set
    __swig_getmethods__["beta"] = _xmm.GMM_beta_get
    if _newclass:
        beta = _swig_property(_xmm.GMM_beta_get, _xmm.GMM_beta_set)
    __swig_setmethods__["covariance_mode_"] = _xmm.GMM_covariance_mode__set
    __swig_getmethods__["covariance_mode_"] = _xmm.GMM_covariance_mode__get
    if _newclass:
        covariance_mode_ = _swig_property(_xmm.GMM_covariance_mode__get, _xmm.GMM_covariance_mode__set)
GMM_swigregister = _xmm.GMM_swigregister
GMM_swigregister(GMM)

class HMM(ProbabilisticModel):
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr
    DEFAULT_NB_STATES = _xmm.HMM_DEFAULT_NB_STATES
    DEFAULT_ESTIMATEMEANS = _xmm.HMM_DEFAULT_ESTIMATEMEANS
    __swig_getmethods__["DEFAULT_EXITPROBABILITY_LAST_STATE"] = lambda x: _xmm.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE
    if _newclass:
        DEFAULT_EXITPROBABILITY_LAST_STATE = staticmethod(_xmm.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE)
    __swig_getmethods__["TRANSITION_REGULARIZATION"] = lambda x: _xmm.HMM_TRANSITION_REGULARIZATION
    if _newclass:
        TRANSITION_REGULARIZATION = staticmethod(_xmm.HMM_TRANSITION_REGULARIZATION)
    ERGODIC = _xmm.HMM_ERGODIC
    LEFT_RIGHT = _xmm.HMM_LEFT_RIGHT
    FULL = _xmm.HMM_FULL
    WINDOWED = _xmm.HMM_WINDOWED
    LIKELIEST = _xmm.HMM_LIKELIEST

    def __init__(self, *args):
        this = _xmm.new_HMM(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_HMM
    __del__ = lambda self: None

    def set_trainingSet(self, trainingSet):
        """
        void
        xmm::ProbabilisticModel::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the dimensions of the model

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.HMM_set_trainingSet(self, trainingSet)


    def get_nbStates(self):
        return _xmm.HMM_get_nbStates(self)

    def set_nbStates(self, nbStates):
        return _xmm.HMM_set_nbStates(self, nbStates)

    def get_nbMixtureComponents(self):
        return _xmm.HMM_get_nbMixtureComponents(self)

    def set_nbMixtureComponents(self, nbMixtureComponents):
        return _xmm.HMM_set_nbMixtureComponents(self, nbMixtureComponents)

    def get_varianceOffset_relative(self):
        return _xmm.HMM_get_varianceOffset_relative(self)

    def get_varianceOffset_absolute(self):
        return _xmm.HMM_get_varianceOffset_absolute(self)

    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        return _xmm.HMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)

    def get_covariance_mode(self):
        return _xmm.HMM_get_covariance_mode(self)

    def set_covariance_mode(self, covariance_mode):
        return _xmm.HMM_set_covariance_mode(self, covariance_mode)

    def get_regression_estimator(self):
        return _xmm.HMM_get_regression_estimator(self)

    def set_regression_estimator(self, regression_estimator):
        return _xmm.HMM_set_regression_estimator(self, regression_estimator)

    def get_transitionMode(self):
        return _xmm.HMM_get_transitionMode(self)

    def set_transitionMode(self, transMode_str):
        return _xmm.HMM_set_transitionMode(self, transMode_str)

    def addExitPoint(self, stateIndex, proba):
        return _xmm.HMM_addExitPoint(self, stateIndex, proba)

    def performance_init(self):
        """
        void xmm::ProbabilisticModel::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.HMM_performance_init(self)


    def performance_update(self, observation):
        """
        virtual double
        xmm::ProbabilisticModel::performance_update(std::vector< float > const
        &observation)=0

        Main Play function: updates the predictions of the model given a new
        observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension' or
        'dimension_input' depending on the mode [unimodal/bimodal])

        likelihood of the observation 
        """
        return _xmm.HMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        xmm::ProbabilisticModel::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.HMM_to_json(self)


    def from_json(self, root):
        """
        void
        xmm::ProbabilisticModel::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.HMM_from_json(self, root)


    def make_bimodal(self, dimension_input):
        return _xmm.HMM_make_bimodal(self, dimension_input)

    def make_unimodal(self):
        return _xmm.HMM_make_unimodal(self)

    def extract_submodel(self, columns):
        return _xmm.HMM_extract_submodel(self, columns)

    def extract_submodel_input(self):
        return _xmm.HMM_extract_submodel_input(self)

    def extract_submodel_output(self):
        return _xmm.HMM_extract_submodel_output(self)

    def extract_inverse_model(self):
        return _xmm.HMM_extract_inverse_model(self)
    __swig_setmethods__["results_progress"] = _xmm.HMM_results_progress_set
    __swig_getmethods__["results_progress"] = _xmm.HMM_results_progress_get
    if _newclass:
        results_progress = _swig_property(_xmm.HMM_results_progress_get, _xmm.HMM_results_progress_set)
    __swig_setmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_set
    __swig_getmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_get
    if _newclass:
        results_exit_likelihood = _swig_property(_xmm.HMM_results_exit_likelihood_get, _xmm.HMM_results_exit_likelihood_set)
    __swig_setmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_set
    __swig_getmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_get
    if _newclass:
        results_exit_ratio = _swig_property(_xmm.HMM_results_exit_ratio_get, _xmm.HMM_results_exit_ratio_set)
    __swig_setmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_set
    __swig_getmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_get
    if _newclass:
        results_likeliest_state = _swig_property(_xmm.HMM_results_likeliest_state_get, _xmm.HMM_results_likeliest_state_set)
    __swig_setmethods__["alpha"] = _xmm.HMM_alpha_set
    __swig_getmethods__["alpha"] = _xmm.HMM_alpha_get
    if _newclass:
        alpha = _swig_property(_xmm.HMM_alpha_get, _xmm.HMM_alpha_set)
    __swig_setmethods__["alpha_h"] = _xmm.HMM_alpha_h_set
    __swig_getmethods__["alpha_h"] = _xmm.HMM_alpha_h_get
    if _newclass:
        alpha_h = _swig_property(_xmm.HMM_alpha_h_get, _xmm.HMM_alpha_h_set)
    __swig_setmethods__["states"] = _xmm.HMM_states_set
    __swig_getmethods__["states"] = _xmm.HMM_states_get
    if _newclass:
        states = _swig_property(_xmm.HMM_states_get, _xmm.HMM_states_set)
    __swig_setmethods__["prior"] = _xmm.HMM_prior_set
    __swig_getmethods__["prior"] = _xmm.HMM_prior_get
    if _newclass:
        prior = _swig_property(_xmm.HMM_prior_get, _xmm.HMM_prior_set)
    __swig_setmethods__["transition"] = _xmm.HMM_transition_set
    __swig_getmethods__["transition"] = _xmm.HMM_transition_get
    if _newclass:
        transition = _swig_property(_xmm.HMM_transition_get, _xmm.HMM_transition_set)
    __swig_setmethods__["covariance_mode_"] = _xmm.HMM_covariance_mode__set
    __swig_getmethods__["covariance_mode_"] = _xmm.HMM_covariance_mode__get
    if _newclass:
        covariance_mode_ = _swig_property(_xmm.HMM_covariance_mode__get, _xmm.HMM_covariance_mode__set)
HMM_swigregister = _xmm.HMM_swigregister
HMM_swigregister(HMM)

def HMM_DEFAULT_EXITPROBABILITY_LAST_STATE():
    return _xmm.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE()
HMM_DEFAULT_EXITPROBABILITY_LAST_STATE = _xmm.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE

def HMM_TRANSITION_REGULARIZATION():
    return _xmm.HMM_TRANSITION_REGULARIZATION()
HMM_TRANSITION_REGULARIZATION = _xmm.HMM_TRANSITION_REGULARIZATION

class _MODELGROUP_GMM(Listener, Writable):
    """


    Handle machine learning models running in parallel.

    templateparam:

    ModelType:  type of the models (implemented: GMM, HMM)

    C++ includes: model_group.h 
    """

    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_GMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_GMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_GMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_GMM
    __del__ = lambda self: None

    def is_training(self):
        return _xmm._MODELGROUP_GMM_is_training(self)

    def is_trained(self, *args):
        """
        bool
        xmm::ModelGroup< ModelType >::is_trained() const

        Check if all models have been trained.

        true if all the models has been trained and the training data has not
        been modified in between 
        """
        return _xmm._MODELGROUP_GMM_is_trained(self, *args)


    def size(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::size() const

        get the number of models

        number of models 
        """
        return _xmm._MODELGROUP_GMM_size(self)


    def clear(self):
        """
        virtual void
        xmm::ModelGroup< ModelType >::clear()

        Remove All models. 
        """
        return _xmm._MODELGROUP_GMM_clear(self)


    def remove(self, label):
        """
        virtual void
        xmm::ModelGroup< ModelType >::remove(Label const &label)

        Remove Specific model.

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm._MODELGROUP_GMM_remove(self, label)


    def set_trainingSet(self, globalTrainingSet):
        """
        void
        xmm::ModelGroup< ModelType >::set_trainingSet(TrainingSet
        *globalTrainingSet)

        Set pointer to the global training set.

        Parameters:
        -----------

        globalTrainingSet:  pointer to the global training set 
        """
        return _xmm._MODELGROUP_GMM_set_trainingSet(self, globalTrainingSet)


    def dimension(self):
        """
        int
        xmm::ModelGroup< ModelType >::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm._MODELGROUP_GMM_dimension(self)


    def dimension_input(self):
        """
        int
        xmm::ModelGroup< ModelType >::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm._MODELGROUP_GMM_dimension_input(self)


    def set_performanceMode(self, performanceMode_str):
        """
        void
        xmm::ModelGroup< ModelType >::set_performanceMode(std::string
        performanceMode_str)

        Sets the performance mode (likeliest vs mixture)

        Parameters:
        -----------

        performanceMode_str:  performance mode: if "likeliest", the
        performance_update function estimates the output modality with the
        likeliest model. If "mixture", the performance_update function
        estimates the output modality as a weighted sum of all models'
        predictions.

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "likeliest" or "mixture"

        """
        return _xmm._MODELGROUP_GMM_set_performanceMode(self, performanceMode_str)


    def get_performanceMode(self):
        """
        std::string xmm::ModelGroup< ModelType >::get_performanceMode()

        Get the performance mode (likeliest vs mixture)

        performance mode: if "likeliest", the performance_update function
        estimates the output modality with the likeliest model. If
        "mixture", the performance_update function estimates the output
        modality as a weighted sum of all models' predictions. 
        """
        return _xmm._MODELGROUP_GMM_get_performanceMode(self)


    def get_EM_minSteps(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::get_EM_minSteps() const

        Get minimum number of EM steps.

        minimum number of steps of the EM algorithm 
        """
        return _xmm._MODELGROUP_GMM_get_EM_minSteps(self)


    def get_EM_maxSteps(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::get_EM_maxSteps() const

        Get maximum number of EM steps.

        maximum number of steps of the EM algorithm

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_GMM_get_EM_maxSteps(self)


    def get_EM_percentChange(self):
        """
        double
        xmm::ModelGroup< ModelType >::get_EM_percentChange() const

        Get EM convergence threshold in percent-change of the likelihood.

        loglikelihood percent-change convergence threshold

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_GMM_get_EM_percentChange(self)


    def set_EM_minSteps(self, steps):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_minSteps(unsigned int steps)

        Set minimum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  minimum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_GMM_set_EM_minSteps(self, steps)


    def set_EM_maxSteps(self, steps):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_maxSteps(unsigned int steps)

        Set maximum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  maximum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_GMM_set_EM_maxSteps(self, steps)


    def set_EM_percentChange(self, logLikPercentChg_):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_percentChange(double
        logLikPercentChg_)

        Set convergence threshold in percent-change of the likelihood.

        Parameters:
        -----------

        logLikPercentChg_:  log-likelihood percent-change convergence
        threshold

        Exceptions:
        -----------

        invalid_argument:  if logLikelihoodPercentChg <= 0 
        """
        return _xmm._MODELGROUP_GMM_set_EM_percentChange(self, logLikPercentChg_)


    def get_likelihoodwindow(self):
        """
        unsigned int xmm::ModelGroup< ModelType >::get_likelihoodwindow()
        const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm._MODELGROUP_GMM_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void
        xmm::ModelGroup< ModelType >::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm._MODELGROUP_GMM_set_likelihoodwindow(self, likelihoodwindow)


    def get_column_names(self):
        """
        std::vector<std::string> const& xmm::ModelGroup< ModelType
        >::get_column_names() const

        get a copy of the column names of the input/output data 
        """
        return _xmm._MODELGROUP_GMM_get_column_names(self)


    def train(self, *args):
        """
        virtual void
        xmm::ModelGroup< ModelType >::train()

        Train All model even if their data have not changed. 
        """
        return _xmm._MODELGROUP_GMM_train(self, *args)

    __swig_getmethods__["joinTraining"] = lambda x: _xmm._MODELGROUP_GMM_joinTraining
    if _newclass:
        joinTraining = staticmethod(_xmm._MODELGROUP_GMM_joinTraining)

    def retrain(self):
        """
        virtual void
        xmm::ModelGroup< ModelType >::retrain()

        Train all model which data has changed. 
        """
        return _xmm._MODELGROUP_GMM_retrain(self)


    def stopTraining(self, *args):
        return _xmm._MODELGROUP_GMM_stopTraining(self, *args)

    def monitor_training(model, state, extradata):
        """
        static void
        xmm::ModelGroup< ModelType >::monitor_training(void *model,
        ProbabilisticModel::CALLBACK_FLAG state, void *extradata)

        Monitors the training of each model of the group. 
        """
        return _xmm._MODELGROUP_GMM_monitor_training(model, state, extradata)

    if _newclass:
        monitor_training = staticmethod(monitor_training)
    __swig_getmethods__["monitor_training"] = lambda x: monitor_training

    def set_trainingCallback(self, callback, extradata):
        """
        void
        xmm::ModelGroup< ModelType
        >::set_trainingCallback(void(*callback)(void *srcModel,
        ProbabilisticModel::CALLBACK_FLAG state, void *extradata), void
        *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm._MODELGROUP_GMM_set_trainingCallback(self, callback, extradata)


    def performance_init(self):
        """
        virtual
        void xmm::ModelGroup< ModelType >::performance_init()

        Initialize Performance. 
        """
        return _xmm._MODELGROUP_GMM_performance_init(self)


    def performance_update(self, observation):
        """
        virtual
        void xmm::ModelGroup< ModelType >::performance_update(std::vector<
        float > const &observation)=0

        Main performance Function: perform joint recognition and mapping (in
        the case of a bimodal model)

        Parameters:
        -----------

        observation:  observation vector. If the model is bimodal, this should
        be allocated for both modalities, and should contain the observation
        on the input modality. The predicted output will be appended to the
        input modality observation 
        """
        return _xmm._MODELGROUP_GMM_performance_update(self, observation)


    def update_likelihood_results(self):
        """
        virtual void xmm::ModelGroup< ModelType >::update_likelihood_results()

        Update the results (Likelihoods) 
        """
        return _xmm._MODELGROUP_GMM_update_likelihood_results(self)

    __swig_setmethods__["models"] = _xmm._MODELGROUP_GMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_GMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_GMM_models_get, _xmm._MODELGROUP_GMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_GMM_globalTrainingSet_get, _xmm._MODELGROUP_GMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_log_likelihoods_get, _xmm._MODELGROUP_GMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_GMM_results_likeliest_get, _xmm._MODELGROUP_GMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_GMM_results_predicted_output_get, _xmm._MODELGROUP_GMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_GMM_results_output_variance_get, _xmm._MODELGROUP_GMM_results_output_variance_set)
_MODELGROUP_GMM_swigregister = _xmm._MODELGROUP_GMM_swigregister
_MODELGROUP_GMM_swigregister(_MODELGROUP_GMM)

def _MODELGROUP_GMM_joinTraining(*args):
    return _xmm._MODELGROUP_GMM_joinTraining(*args)
_MODELGROUP_GMM_joinTraining = _xmm._MODELGROUP_GMM_joinTraining

def _MODELGROUP_GMM_monitor_training(model, state, extradata):
    """
    static void
    xmm::ModelGroup< ModelType >::monitor_training(void *model,
    ProbabilisticModel::CALLBACK_FLAG state, void *extradata)

    Monitors the training of each model of the group. 
    """
    return _xmm._MODELGROUP_GMM_monitor_training(model, state, extradata)

class _MODELGROUP_HMM(Listener, Writable):
    """


    Handle machine learning models running in parallel.

    templateparam:

    ModelType:  type of the models (implemented: GMM, HMM)

    C++ includes: model_group.h 
    """

    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_HMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_HMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_HMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_HMM
    __del__ = lambda self: None

    def is_training(self):
        return _xmm._MODELGROUP_HMM_is_training(self)

    def is_trained(self, *args):
        """
        bool
        xmm::ModelGroup< ModelType >::is_trained() const

        Check if all models have been trained.

        true if all the models has been trained and the training data has not
        been modified in between 
        """
        return _xmm._MODELGROUP_HMM_is_trained(self, *args)


    def size(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::size() const

        get the number of models

        number of models 
        """
        return _xmm._MODELGROUP_HMM_size(self)


    def clear(self):
        """
        virtual void
        xmm::ModelGroup< ModelType >::clear()

        Remove All models. 
        """
        return _xmm._MODELGROUP_HMM_clear(self)


    def remove(self, label):
        """
        virtual void
        xmm::ModelGroup< ModelType >::remove(Label const &label)

        Remove Specific model.

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm._MODELGROUP_HMM_remove(self, label)


    def set_trainingSet(self, globalTrainingSet):
        """
        void
        xmm::ModelGroup< ModelType >::set_trainingSet(TrainingSet
        *globalTrainingSet)

        Set pointer to the global training set.

        Parameters:
        -----------

        globalTrainingSet:  pointer to the global training set 
        """
        return _xmm._MODELGROUP_HMM_set_trainingSet(self, globalTrainingSet)


    def dimension(self):
        """
        int
        xmm::ModelGroup< ModelType >::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm._MODELGROUP_HMM_dimension(self)


    def dimension_input(self):
        """
        int
        xmm::ModelGroup< ModelType >::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm._MODELGROUP_HMM_dimension_input(self)


    def set_performanceMode(self, performanceMode_str):
        """
        void
        xmm::ModelGroup< ModelType >::set_performanceMode(std::string
        performanceMode_str)

        Sets the performance mode (likeliest vs mixture)

        Parameters:
        -----------

        performanceMode_str:  performance mode: if "likeliest", the
        performance_update function estimates the output modality with the
        likeliest model. If "mixture", the performance_update function
        estimates the output modality as a weighted sum of all models'
        predictions.

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "likeliest" or "mixture"

        """
        return _xmm._MODELGROUP_HMM_set_performanceMode(self, performanceMode_str)


    def get_performanceMode(self):
        """
        std::string xmm::ModelGroup< ModelType >::get_performanceMode()

        Get the performance mode (likeliest vs mixture)

        performance mode: if "likeliest", the performance_update function
        estimates the output modality with the likeliest model. If
        "mixture", the performance_update function estimates the output
        modality as a weighted sum of all models' predictions. 
        """
        return _xmm._MODELGROUP_HMM_get_performanceMode(self)


    def get_EM_minSteps(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::get_EM_minSteps() const

        Get minimum number of EM steps.

        minimum number of steps of the EM algorithm 
        """
        return _xmm._MODELGROUP_HMM_get_EM_minSteps(self)


    def get_EM_maxSteps(self):
        """
        unsigned int
        xmm::ModelGroup< ModelType >::get_EM_maxSteps() const

        Get maximum number of EM steps.

        maximum number of steps of the EM algorithm

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_HMM_get_EM_maxSteps(self)


    def get_EM_percentChange(self):
        """
        double
        xmm::ModelGroup< ModelType >::get_EM_percentChange() const

        Get EM convergence threshold in percent-change of the likelihood.

        loglikelihood percent-change convergence threshold

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_HMM_get_EM_percentChange(self)


    def set_EM_minSteps(self, steps):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_minSteps(unsigned int steps)

        Set minimum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  minimum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_HMM_set_EM_minSteps(self, steps)


    def set_EM_maxSteps(self, steps):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_maxSteps(unsigned int steps)

        Set maximum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  maximum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_HMM_set_EM_maxSteps(self, steps)


    def set_EM_percentChange(self, logLikPercentChg_):
        """
        void
        xmm::ModelGroup< ModelType >::set_EM_percentChange(double
        logLikPercentChg_)

        Set convergence threshold in percent-change of the likelihood.

        Parameters:
        -----------

        logLikPercentChg_:  log-likelihood percent-change convergence
        threshold

        Exceptions:
        -----------

        invalid_argument:  if logLikelihoodPercentChg <= 0 
        """
        return _xmm._MODELGROUP_HMM_set_EM_percentChange(self, logLikPercentChg_)


    def get_likelihoodwindow(self):
        """
        unsigned int xmm::ModelGroup< ModelType >::get_likelihoodwindow()
        const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm._MODELGROUP_HMM_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void
        xmm::ModelGroup< ModelType >::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm._MODELGROUP_HMM_set_likelihoodwindow(self, likelihoodwindow)


    def get_column_names(self):
        """
        std::vector<std::string> const& xmm::ModelGroup< ModelType
        >::get_column_names() const

        get a copy of the column names of the input/output data 
        """
        return _xmm._MODELGROUP_HMM_get_column_names(self)


    def train(self, *args):
        """
        virtual void
        xmm::ModelGroup< ModelType >::train()

        Train All model even if their data have not changed. 
        """
        return _xmm._MODELGROUP_HMM_train(self, *args)

    __swig_getmethods__["joinTraining"] = lambda x: _xmm._MODELGROUP_HMM_joinTraining
    if _newclass:
        joinTraining = staticmethod(_xmm._MODELGROUP_HMM_joinTraining)

    def retrain(self):
        """
        virtual void
        xmm::ModelGroup< ModelType >::retrain()

        Train all model which data has changed. 
        """
        return _xmm._MODELGROUP_HMM_retrain(self)


    def stopTraining(self, *args):
        return _xmm._MODELGROUP_HMM_stopTraining(self, *args)

    def monitor_training(model, state, extradata):
        """
        static void
        xmm::ModelGroup< ModelType >::monitor_training(void *model,
        ProbabilisticModel::CALLBACK_FLAG state, void *extradata)

        Monitors the training of each model of the group. 
        """
        return _xmm._MODELGROUP_HMM_monitor_training(model, state, extradata)

    if _newclass:
        monitor_training = staticmethod(monitor_training)
    __swig_getmethods__["monitor_training"] = lambda x: monitor_training

    def set_trainingCallback(self, callback, extradata):
        """
        void
        xmm::ModelGroup< ModelType
        >::set_trainingCallback(void(*callback)(void *srcModel,
        ProbabilisticModel::CALLBACK_FLAG state, void *extradata), void
        *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm._MODELGROUP_HMM_set_trainingCallback(self, callback, extradata)


    def performance_init(self):
        """
        virtual
        void xmm::ModelGroup< ModelType >::performance_init()

        Initialize Performance. 
        """
        return _xmm._MODELGROUP_HMM_performance_init(self)


    def performance_update(self, observation):
        """
        virtual
        void xmm::ModelGroup< ModelType >::performance_update(std::vector<
        float > const &observation)=0

        Main performance Function: perform joint recognition and mapping (in
        the case of a bimodal model)

        Parameters:
        -----------

        observation:  observation vector. If the model is bimodal, this should
        be allocated for both modalities, and should contain the observation
        on the input modality. The predicted output will be appended to the
        input modality observation 
        """
        return _xmm._MODELGROUP_HMM_performance_update(self, observation)


    def update_likelihood_results(self):
        """
        virtual void xmm::ModelGroup< ModelType >::update_likelihood_results()

        Update the results (Likelihoods) 
        """
        return _xmm._MODELGROUP_HMM_update_likelihood_results(self)

    __swig_setmethods__["models"] = _xmm._MODELGROUP_HMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_HMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_HMM_models_get, _xmm._MODELGROUP_HMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_HMM_globalTrainingSet_get, _xmm._MODELGROUP_HMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_log_likelihoods_get, _xmm._MODELGROUP_HMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_HMM_results_likeliest_get, _xmm._MODELGROUP_HMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_HMM_results_predicted_output_get, _xmm._MODELGROUP_HMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_HMM_results_output_variance_get, _xmm._MODELGROUP_HMM_results_output_variance_set)
_MODELGROUP_HMM_swigregister = _xmm._MODELGROUP_HMM_swigregister
_MODELGROUP_HMM_swigregister(_MODELGROUP_HMM)

def _MODELGROUP_HMM_joinTraining(*args):
    return _xmm._MODELGROUP_HMM_joinTraining(*args)
_MODELGROUP_HMM_joinTraining = _xmm._MODELGROUP_HMM_joinTraining

def _MODELGROUP_HMM_monitor_training(model, state, extradata):
    """
    static void
    xmm::ModelGroup< ModelType >::monitor_training(void *model,
    ProbabilisticModel::CALLBACK_FLAG state, void *extradata)

    Monitors the training of each model of the group. 
    """
    return _xmm._MODELGROUP_HMM_monitor_training(model, state, extradata)

class GMMGroup(_MODELGROUP_GMM):
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMMGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMMGroup, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _xmm.new_GMMGroup(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_nbMixtureComponents(self):
        return _xmm.GMMGroup_get_nbMixtureComponents(self)

    def get_varianceOffset_relative(self):
        return _xmm.GMMGroup_get_varianceOffset_relative(self)

    def get_varianceOffset_absolute(self):
        return _xmm.GMMGroup_get_varianceOffset_absolute(self)

    def set_nbMixtureComponents(self, nbMixtureComponents):
        return _xmm.GMMGroup_set_nbMixtureComponents(self, nbMixtureComponents)

    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        return _xmm.GMMGroup_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)

    def get_covariance_mode(self):
        return _xmm.GMMGroup_get_covariance_mode(self)

    def set_covariance_mode(self, covariance_mode):
        return _xmm.GMMGroup_set_covariance_mode(self, covariance_mode)

    def performance_update(self, observation):
        return _xmm.GMMGroup_performance_update(self, observation)

    def to_json(self):
        """
        virtual JSONNode
        xmm::Writable::to_json() const  =0

        Write to JSON Node.

        JSON Node containing phrase information Todo include type attribute in
        each to_json function 
        """
        return _xmm.GMMGroup_to_json(self)


    def from_json(self, root):
        """
        virtual void
        xmm::Writable::from_json(JSONNode root)=0

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format

        Todo add force_conversion optional argument? 
        """
        return _xmm.GMMGroup_from_json(self, root)


    def make_bimodal(self, dimension_input):
        return _xmm.GMMGroup_make_bimodal(self, dimension_input)

    def make_unimodal(self):
        return _xmm.GMMGroup_make_unimodal(self)

    def extract_submodel(self, columns):
        return _xmm.GMMGroup_extract_submodel(self, columns)

    def extract_submodel_input(self):
        return _xmm.GMMGroup_extract_submodel_input(self)

    def extract_submodel_output(self):
        return _xmm.GMMGroup_extract_submodel_output(self)

    def extract_inverse_model(self):
        return _xmm.GMMGroup_extract_inverse_model(self)
    __swig_destroy__ = _xmm.delete_GMMGroup
    __del__ = lambda self: None
GMMGroup_swigregister = _xmm.GMMGroup_swigregister
GMMGroup_swigregister(GMMGroup)

class HierarchicalHMM(_MODELGROUP_HMM):
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HierarchicalHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HierarchicalHMM, name)
    __repr__ = _swig_repr
    __swig_getmethods__["DEFAULT_EXITTRANSITION"] = lambda x: _xmm.HierarchicalHMM_DEFAULT_EXITTRANSITION
    if _newclass:
        DEFAULT_EXITTRANSITION = staticmethod(_xmm.HierarchicalHMM_DEFAULT_EXITTRANSITION)
    DEFAULT_INCREMENTALLEARNING = _xmm.HierarchicalHMM_DEFAULT_INCREMENTALLEARNING
    DEFAULT_REGULARIZATIONFACTOR = _xmm.HierarchicalHMM_DEFAULT_REGULARIZATIONFACTOR

    def __init__(self, *args):
        this = _xmm.new_HierarchicalHMM(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _xmm.delete_HierarchicalHMM
    __del__ = lambda self: None

    def clear(self):
        return _xmm.HierarchicalHMM_clear(self)

    def get_nbStates(self):
        return _xmm.HierarchicalHMM_get_nbStates(self)

    def set_nbStates(self, nbStates):
        return _xmm.HierarchicalHMM_set_nbStates(self, nbStates)

    def get_nbMixtureComponents(self):
        return _xmm.HierarchicalHMM_get_nbMixtureComponents(self)

    def set_nbMixtureComponents(self, nbMixtureComponents):
        return _xmm.HierarchicalHMM_set_nbMixtureComponents(self, nbMixtureComponents)

    def get_varianceOffset_relative(self):
        return _xmm.HierarchicalHMM_get_varianceOffset_relative(self)

    def get_varianceOffset_absolute(self):
        return _xmm.HierarchicalHMM_get_varianceOffset_absolute(self)

    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        return _xmm.HierarchicalHMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)

    def get_covariance_mode(self):
        return _xmm.HierarchicalHMM_get_covariance_mode(self)

    def set_covariance_mode(self, covariance_mode):
        return _xmm.HierarchicalHMM_set_covariance_mode(self, covariance_mode)

    def get_regression_estimator(self):
        return _xmm.HierarchicalHMM_get_regression_estimator(self)

    def set_regression_estimator(self, regression_estimator):
        return _xmm.HierarchicalHMM_set_regression_estimator(self, regression_estimator)

    def get_transitionMode(self):
        return _xmm.HierarchicalHMM_get_transitionMode(self)

    def set_transitionMode(self, transMode_str):
        return _xmm.HierarchicalHMM_set_transitionMode(self, transMode_str)

    def get_estimateMeans(self):
        return _xmm.HierarchicalHMM_get_estimateMeans(self)

    def set_estimateMeans(self, _estimateMeans):
        return _xmm.HierarchicalHMM_set_estimateMeans(self, _estimateMeans)

    def addExitPoint(self, state, proba):
        return _xmm.HierarchicalHMM_addExitPoint(self, state, proba)

    def get_learningMode(self):
        return _xmm.HierarchicalHMM_get_learningMode(self)

    def set_learningMode(self, learningMode):
        return _xmm.HierarchicalHMM_set_learningMode(self, learningMode)

    def get_prior(self, prior):
        return _xmm.HierarchicalHMM_get_prior(self, prior)

    def set_prior(self, prior):
        return _xmm.HierarchicalHMM_set_prior(self, prior)

    def get_transition(self, trans):
        return _xmm.HierarchicalHMM_get_transition(self, trans)

    def set_transition(self, trans):
        return _xmm.HierarchicalHMM_set_transition(self, trans)

    def get_exitTransition(self, trans):
        return _xmm.HierarchicalHMM_get_exitTransition(self, trans)

    def set_exitTransition(self, exittrans):
        return _xmm.HierarchicalHMM_set_exitTransition(self, exittrans)

    def setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba):
        return _xmm.HierarchicalHMM_setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba)

    def remove(self, label):
        return _xmm.HierarchicalHMM_remove(self, label)

    def performance_init(self):
        return _xmm.HierarchicalHMM_performance_init(self)

    def performance_update(self, observation):
        return _xmm.HierarchicalHMM_performance_update(self, observation)

    def to_json(self):
        """
        virtual JSONNode
        xmm::Writable::to_json() const  =0

        Write to JSON Node.

        JSON Node containing phrase information Todo include type attribute in
        each to_json function 
        """
        return _xmm.HierarchicalHMM_to_json(self)


    def from_json(self, root):
        """
        virtual void
        xmm::Writable::from_json(JSONNode root)=0

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format

        Todo add force_conversion optional argument? 
        """
        return _xmm.HierarchicalHMM_from_json(self, root)


    def make_bimodal(self, dimension_input):
        return _xmm.HierarchicalHMM_make_bimodal(self, dimension_input)

    def make_unimodal(self):
        return _xmm.HierarchicalHMM_make_unimodal(self)

    def extract_submodel(self, columns):
        return _xmm.HierarchicalHMM_extract_submodel(self, columns)

    def extract_submodel_input(self):
        return _xmm.HierarchicalHMM_extract_submodel_input(self)

    def extract_submodel_output(self):
        return _xmm.HierarchicalHMM_extract_submodel_output(self)

    def extract_inverse_model(self):
        return _xmm.HierarchicalHMM_extract_inverse_model(self)
    __swig_setmethods__["prior"] = _xmm.HierarchicalHMM_prior_set
    __swig_getmethods__["prior"] = _xmm.HierarchicalHMM_prior_get
    if _newclass:
        prior = _swig_property(_xmm.HierarchicalHMM_prior_get, _xmm.HierarchicalHMM_prior_set)
    __swig_setmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_set
    __swig_getmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_get
    if _newclass:
        exitTransition = _swig_property(_xmm.HierarchicalHMM_exitTransition_get, _xmm.HierarchicalHMM_exitTransition_set)
    __swig_setmethods__["transition"] = _xmm.HierarchicalHMM_transition_set
    __swig_getmethods__["transition"] = _xmm.HierarchicalHMM_transition_get
    if _newclass:
        transition = _swig_property(_xmm.HierarchicalHMM_transition_get, _xmm.HierarchicalHMM_transition_set)
HierarchicalHMM_swigregister = _xmm.HierarchicalHMM_swigregister
HierarchicalHMM_swigregister(HierarchicalHMM)

def HierarchicalHMM_DEFAULT_EXITTRANSITION():
    return _xmm.HierarchicalHMM_DEFAULT_EXITTRANSITION()
HierarchicalHMM_DEFAULT_EXITTRANSITION = _xmm.HierarchicalHMM_DEFAULT_EXITTRANSITION

# This file is compatible with both classic and new-style classes.


